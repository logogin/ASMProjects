<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE> Описание системы команд микропроцессора Pentium</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF">
<!базовый размер символов (для всего документа><!тело html-документа>
<HR SIZE=5 WIDTH=60%>
<CENTER>
<H1>
Описание системы команд</H1></CENTER>

<CENTER>
<H1>
микропроцессоров Intel</H1></CENTER>
<FONT SIZE=+0>Материал, приведенный в данном разделе справочной системы,
связан с уроком 6, на котором мы рассматривали формат машинной команды
микропроцессора и систему его команд в целом.</FONT>
<CENTER></CENTER>

<CENTER><B><I><FONT SIZE=+1>Выберите тему:</FONT></I></B></CENTER>


<P><B><FONT SIZE=+0><A HREF="#1">Знакомство с порядком описания команд
и принятыми обозначениями</A></FONT></B>
<BR><B><FONT SIZE=+0><A HREF="#2">Описание команд микропроцессора, упорядоченное
по алфавиту</A></FONT></B>
<BR><B><FONT SIZE=+0><A HREF="Function.htm">Описание команд микропроцессора,
упорядоченное по функциональному признаку</A></FONT></B>
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;

<P><A NAME="2"></A>
<TABLE BORDER=2 COLS=7 BGCOLOR="#CFFFCF" >
<TR ALIGN=CENTER>
<TD><B><A HREF="#aaa">aaa</A></B></TD>

<TD><B><A HREF="#aad">aad</A></B></TD>

<TD><B><A HREF="#aam">aam</A></B></TD>

<TD><B><A HREF="#aas">aas</A></B></TD>

<TD><B><A HREF="#adc">adc</A></B></TD>

<TD><B><A HREF="#add">add</A></B></TD>

<TD><B><A HREF="#and">and</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#bound">bound</A></B></TD>

<TD><B><A HREF="#bsf">bsf</A></B></TD>

<TD><B><A HREF="#bsr">bsr</A></B></TD>

<TD><B><A HREF="#bswap">bswap</A></B></TD>

<TD><B><A HREF="#bt">bt</A></B></TD>

<TD><B><A HREF="#btc">btc</A></B></TD>

<TD><B><A HREF="#btr">btr</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#bts">bts</A></B></TD>

<TD><B><A HREF="#call">call</A></B></TD>

<TD><B><A HREF="#cbw">cbw</A></B></TD>

<TD><B><A HREF="#cbw">cwde</A></B></TD>

<TD><B><A HREF="#clc">clc</A></B></TD>

<TD><B><A HREF="#cld">cld</A></B></TD>

<TD><B><A HREF="#cli">cli</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#cmc">cmc</A></B></TD>

<TD><B><A HREF="#cmp">cmp</A></B></TD>

<TD><B><A HREF="#cmps">cmps/cmpsb</A></B>&nbsp;
<BR><B><A HREF="#cmps">/cmpsw/cmpsd</A></B></TD>

<TD><B><A HREF="#cmpxchg">cmpxchg</A></B></TD>

<TD><B><A HREF="#cwd">cwd</A></B></TD>

<TD><B><A HREF="#cdq">cdq</A></B></TD>

<TD><B><A HREF="#daa">daa</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#das">das</A></B></TD>

<TD><B><A HREF="#dec">dec</A></B></TD>

<TD><B><A HREF="#div">div</A></B></TD>

<TD><B><A HREF="#enter">enter</A></B></TD>

<TD><B><A HREF="#hlt">hlt</A></B></TD>

<TD><B><A HREF="#idiv">idiv</A></B></TD>

<TD><B><A HREF="#imul">imul</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#in">in</A></B></TD>

<TD><B><A HREF="#inc">inc</A></B></TD>

<TD><B><A HREF="#ins">ins/insb</A></B>&nbsp;
<BR><B><A HREF="#ins">/insw/insd</A></B></TD>

<TD><B><A HREF="#int">int</A></B></TD>

<TD><B><A HREF="#into">into</A></B></TD>

<TD><B><A HREF="#iret">iret/iretd</A></B></TD>

<TD><B><A HREF="#jcc">jcc</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#jcc">jcxz</A></B></TD>

<TD><B><A HREF="#jcc">jecxz</A></B></TD>

<TD><B><A HREF="#jmp">jmp</A></B></TD>

<TD><B><A HREF="#lahf">lahf</A></B></TD>

<TD><B><A HREF="#lds">lds</A></B></TD>

<TD><B><A HREF="#lds">les</A></B></TD>

<TD><B><A HREF="#lds">lfs</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#lds">lgs</A></B></TD>

<TD><B><A HREF="#lds">lss</A></B></TD>

<TD><B><A HREF="#lea">lea</A></B></TD>

<TD><B><A HREF="#leave">leave</A></B></TD>

<TD><B><A HREF="#lgdt">lgdt</A></B></TD>

<TD><B><A HREF="#lidt">lidt</A></B></TD>

<TD><B><A HREF="#lods">lods/lodsb</A></B>&nbsp;
<BR><B><A HREF="#lods">/lodsw/lodsd</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#loop">loop</A></B></TD>

<TD><B><A HREF="#loope">loope</A></B></TD>

<TD><B><A HREF="#loope">loopz</A></B></TD>

<TD><B><A HREF="#loope">loopne</A></B></TD>

<TD><B><A HREF="#loope">loopnz</A></B></TD>

<TD><B><A HREF="#mov">mov</A></B></TD>

<TD><B><A HREF="#movs">movs/movsb</A></B>&nbsp;
<BR><B><A HREF="#movs">/movsw/movsd</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#movsx">movsx</A></B></TD>

<TD><B><A HREF="#movzx">movzx</A></B></TD>

<TD><B><A HREF="#mul">mul</A></B></TD>

<TD><B><A HREF="#neg">neg</A></B></TD>

<TD><B><A HREF="#nop">nop</A></B></TD>

<TD><B><A HREF="#not">not</A></B></TD>

<TD><B><A HREF="#or">or</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#out">out</A></B></TD>

<TD><B><A HREF="#outs">outs</A></B></TD>

<TD><B><A HREF="#pop">pop</A></B></TD>

<TD><B><A HREF="#popa">popa</A></B></TD>

<TD><B><A HREF="#popad">popad</A></B></TD>

<TD><B><A HREF="#popf">popf</A></B></TD>

<TD><B><A HREF="#popfd">popfd</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#push">push</A></B></TD>

<TD><B><A HREF="#pusha">pusha</A></B></TD>

<TD><B><A HREF="#pushad">pushad</A></B></TD>

<TD><B><A HREF="#pushf">pushf</A></B></TD>

<TD><B><A HREF="#pushfd">pushfd</A></B></TD>

<TD><B><A HREF="#rcl">rcl</A></B></TD>

<TD><B><A HREF="#rcr">rcr</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#rep">rep/repe/repz</A></B>&nbsp;
<BR><B><A HREF="#rep">/repne/repnz</A></B></TD>

<TD><B><A HREF="#ret">ret/retf</A></B></TD>

<TD><B><A HREF="#rol">rol</A></B></TD>

<TD><B><A HREF="#ror">ror</A></B></TD>

<TD><B><A HREF="#sahf">sahf</A></B></TD>

<TD><B><A HREF="#sal">sal</A></B></TD>

<TD><B><A HREF="#sar">sar</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#sbb">sbb</A></B></TD>

<TD><B><A HREF="#scas">scas/scasb</A></B>&nbsp;
<BR><B><A HREF="#scas">/scasw/scasd</A></B></TD>

<TD><B><A HREF="#setcc">setcc</A></B></TD>

<TD><B><A HREF="#sgdt">sgdt</A></B></TD>

<TD><B><A HREF="#sidt">sidt</A></B></TD>

<TD><B><A HREF="#shl">shl</A></B></TD>

<TD><B><A HREF="#shld">shld</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#shr">shr</A></B></TD>

<TD><B><A HREF="#shrd">shrd</A></B></TD>

<TD><B><A HREF="#stc">stc</A></B></TD>

<TD><B><A HREF="#std">std</A></B></TD>

<TD><B><A HREF="#sti">sti</A></B></TD>

<TD><B><A HREF="#stos">stos/stosb</A></B>&nbsp;
<BR><B><A HREF="#stos">/stosw/stosd</A></B></TD>

<TD><B><A HREF="#sub">sub</A></B></TD>
</TR>

<TR ALIGN=CENTER>
<TD><B><A HREF="#test">test</A></B></TD>

<TD><B><A HREF="#xadd">xadd</A></B></TD>

<TD><B><A HREF="#xchg">xchg</A></B></TD>

<TD><B><A HREF="#xlatb">xlat/xlatb</A></B></TD>

<TD><B><A HREF="#xor">xor</A></B></TD>

<TD><B><A HREF="#xor">&nbsp;</A></B></TD>

<TD><B><A HREF="#xor">&nbsp;</A></B></TD>
</TR>
</TABLE>
&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;

<P><A NAME="1"></A>
<CENTER>
<H3>
<FONT SIZE=+0>Порядок описания команд будет следующим:</FONT></H3></CENTER>
&nbsp;
<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>название команды с расшифровкой ее мнемонического обозначения
— это облегчит процесс запоминания и последующего использования команды
в соответствии с ее функциональным назначением;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>синтаксическое описание команды, поясняющее возможные сочетания
операндов для данной команды. При этом сложные синтаксические описания
будут приведены в виде синтаксических диаграмм, что позволит в наиболее
компактной форме изобразить все возможные сочетания операндов;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>состояние флагов после выполнения команды;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>описание типового применения команды с примером и (или) ссылка
на урок, в котором демонстрируется пример применения команды;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>номера занятий и приложений, а также список команд, которые
функционально связаны с данной командой.</FONT></LI>
</UL>

<CENTER>
<H3>
<FONT SIZE=+0>Для описания команд приняты обозначения:</FONT></H3></CENTER>

<OL>
<LI>
<FONT SIZE=+0>Для описания состояния флагов после выполнения некоторой
команды будем использовать выборку из таблицы, отражающей структуру регистра
флагов <TT>eflags</TT>:</FONT></LI>

<TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>31</TD>

<TD>18</TD>

<TD>17</TD>

<TD>16</TD>

<TD>15</TD>

<TD>14</TD>

<TD>1312</TD>

<TD>11</TD>

<TD>10</TD>

<TD>09</TD>

<TD>08</TD>

<TD>07</TD>

<TD>06</TD>

<TD>05</TD>

<TD>04</TD>

<TD>03</TD>

<TD>02</TD>

<TD>01</TD>

<TD>00</TD>
</TR>

<TR>
<TD>0</TD>

<TD>0</TD>

<TD>VM</TD>

<TD>RF</TD>

<TD>0</TD>

<TD>NT</TD>

<TD>IOPL</TD>

<TD>OF</TD>

<TD>DF</TD>

<TD>IF</TD>

<TD>TF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>0</TD>

<TD>AF</TD>

<TD>0</TD>

<TD>PF</TD>

<TD>1</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>&nbsp;</TD>
</TR>
</TABLE>
<FONT SIZE=+0>В нижней строке этой таблицы приводятся значения флагов после
выполнения команды. При этом используются следующие обозначения:</FONT>
<UL>
<LI TYPE="DISK">
<FONT SIZE=+0><I>1</I> — после выполнения команды флаг устанавливается
(равен 1);</FONT></LI>

<LI TYPE="DISK">
<FONT SIZE=+0><I>0</I> — после выполнения команды флаг сбрасывается (равен
0);</FONT></LI>

<LI TYPE="DISK">
<FONT SIZE=+0><I>r</I> — значение флага зависит от результата работы команды;</FONT></LI>

<LI TYPE="DISK">
<FONT SIZE=+0><I>?</I> — после выполнения команды флаг не определен;</FONT></LI>

<LI TYPE="DISK">
<FONT SIZE=+0>пробел — после выполнения команды флаг не изменяется;</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0>Для представления операндов в синтаксических диаграммах используются
следующие обозначения:</FONT></LI>

<UL>
<LI TYPE="DISK">
<FONT SIZE=+0><I>r8, r16, r32</I> — операнд в одном из регистров размером
байт, слово или двойное слово;</FONT></LI>

<LI TYPE="DISK">
<FONT SIZE=+0><I>m8, m16, m32, m48</I> — операнд в памяти размером байт,
слово, двойное слово или 48 бит;</FONT></LI>

<LI TYPE="DISK">
<FONT SIZE=+0><I>i8, i16, i32</I> — непосредственный операнд размером байт,
слово или двойное слово;</FONT></LI>

<LI TYPE="DISK">
<FONT SIZE=+0><I>a8, a16, a32</I> — относительный адрес (смещение) в сегменте
кода.</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0>На многих диаграммах в целях компактности возможные сочетания
операндов показаны в виде следующей конструкции:</FONT></LI>

<CENTER><IMG SRC="../Pic/P_2_1.gif" ></CENTER>


<P><FONT SIZE=+0>Конструируя команду на основе подобной синтаксической
диаграммы, вы должны помнить о соответствии типов. В подобной диаграмме
допустимы только следующие сочетания: "r8, m8", "r16, m16", "r32, m32".
Например, сочетание "r8, m16" недопустимо. Однако есть единичные случаи,
когда подобные сочетания возможны; тогда они специально оговариваются.</FONT>
<LI>
<FONT SIZE=+0>Описанная в данном приложении система команд в полном объеме
поддерживается микропроцессором Pentium. Предыдущие модели микропроцессора
могут не поддерживать отдельные команды. Чтобы прояснить этот момент, мы
будем указывать в примерах для каждой команды директиву типа .286. Это
будет означать, что описываемая команда поддерживается всеми моделями микропроцессора,
начиная с i286. Если ничего не указывается, то это означает, что данная
команда работает на всех моделях микропроцессоров Intel, начиная с i8086/8088.</FONT></LI>
</OL>
<A NAME="aaa"></A>
<CENTER>
<H2>
AAA</H2></CENTER>

<CENTER><FONT SIZE=+1>(Ascii Adjust after Addition)</FONT></CENTER>

<CENTER><FONT SIZE=+1>ASCII-коррекция после сложения</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>aaa&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> корректировка неупакованного результата
сложения двух одноразрядных неупакованных BCD-чисел.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_2.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>проанализировать значение младшего полубайта регистра al
и значение флага af;</FONT></LI>

<LI>
<FONT SIZE=+0>если (значение младшего полубайта регистра al >9) или (AF=1),
то выполнить следующие действия:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>увеличить значение al на 6;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>очистить старший полубайт регистра al;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>увеличить значение ah на 1;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>установить флаги: af = 1, cf = 1,</FONT></LI>
</UL>
<FONT SIZE=+0>иначе сбросить флаги af = 0 и cf = 0.</FONT></UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>?&nbsp;</TD>

<TD>?&nbsp;</TD>

<TD>r</TD>

<TD>?</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Обычно команда aaa используется после сложения каждого
разряда распакованных BCD-чисел командой add. Каждая цифра неупакованного
BCD-числа занимает младший полубайт байта. Если результат сложения двух
одноразрядных BCD-чисел больше 9, то число в младшем полубайте результата
не есть BCD-число. Поэтому результат нужно корректировать командой aaa.
Эта команда позволяет сформировать правильное BCD-число в младшем полубайте
и запомнить единицу переноса в старший разряд путем увеличения содержимого
регистра ah на 1.</FONT>
<BR><FONT SIZE=+0>К примеру, сложить два неупакованных BCD-числа: 08 +
05:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,08h&nbsp; ;ah=08h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,05h&nbsp; ;al=05h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; al,ah&nbsp;&nbsp; ;al=al+ah=05h+08h=0dh — не BCD-число
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; ah,ah&nbsp;&nbsp; ;ah=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aaa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ah=01h,al=03h — результат скорректирован
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, приложение 7 и команды <A HREF="#aad">aad</A>,
<A HREF="#aam">aam</A>, <A HREF="#aas">aas</A>, <A HREF="#daa">daa</A>,
<A HREF="#das">das</A></FONT>
<BR><A NAME="aad"></A>
<CENTER>
<H2>
AAD</H2></CENTER>

<CENTER><FONT SIZE=+1>(Ascii Adjust before Division)</FONT></CENTER>

<CENTER><FONT SIZE=+1>ASCII-коррекция перед делением</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>aad&nbsp;</FONT></TD>
</TR>
</TABLE>
<I><FONT SIZE=+0>Назначение:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>подготовкa двух неупакованных BCD-чисел для операции деления;</FONT></LI>

<LI>
<FONT SIZE=+0>преобразование двузначного неупакованного ВCD-числа меньшего
63h (99<SUB>10</SUB>) в двоичное представление.</FONT></LI>
</UL>
<I><FONT SIZE=+0><A HREF="../Pic/P_2_3.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>умножить значение регистра ah на 10 и сложить полученное
значение с содержимым регистра al: (ah*10)+al;</FONT></LI>

<LI>
<FONT SIZE=+0>присвоить регистру al значение (ah*10)+al;</FONT></LI>

<LI>
<FONT SIZE=+0>обнулить регистр ah.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>r&nbsp;</TD>

<TD>r&nbsp;</TD>

<TD>r&nbsp;</TD>

<TD>r&nbsp;</TD>

<TD>?</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду aad используют для подготовки двузначного неупакованного
BCD-числа в регистре ax для операции деления. Так как в системе команд
микропроцессора нет команды деления для BCD-чисел, такое число нужно предварительно
преобразовать в двоичный вид. Для этого старший разряд двузначного BCD-числа
помещается в регистр ah, умножается на 10 и складывается с разрядом единиц
двузначного BCD-числа 9 в регистре al. В результате этих действий и получается
соответствующее двоичное число в регистре ax. Далее в программе уже можно
применять обычную команду деления div, оперирующую двоичными данными. Команду
aad можно применять и просто для преобразования неупакованного двузначного
BCD-числа в его двоичный эквивалент. Есть еще интересный момент — если
посмотреть на коды символов шестнадцатеричных цифр в таблице ASCII, то
видно, что они похожи на BCD-числа. Исключение составляет лишь значение
старшей тетрады (для BCD-числа это так называемая зона с нулевым значением)
- оно равно 3. Можно сделать вывод, что если предварительно обнулить значение
старшей тетрады для кодов двух символов (от 0 до 9), то эту команду вполне
можно применять и для преобразования двузначных десятичных чисел в символьном
представлении в их двоичный эквивалент, что и отражено в названии команды.
Для иллюстрации рассмотрим два примера.</FONT>

<P><FONT SIZE=+0>Пример 1. Разделить десятичное число 18 на 9. Подготовить
результат к выводу на экран.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,01h&nbsp; ;ah=01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,08h&nbsp; ;al=08h => ax=0108h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl,09&nbsp;&nbsp; ;bl=09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aаd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;al=12h — двоичный эквивалент десятичного числа 18
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div&nbsp;&nbsp;&nbsp;&nbsp; bl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;al=02h,ah=00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ог&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,30h&nbsp; ;al=32h — ASCII-представление числа 2, можно выводить на экран
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Пример 2. Преобразовать десятичное число 16 в символьном
виде в эквивалентное двоичное число.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,3136h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ax=3136h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; ax,0f0fh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ax=0106h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aаd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;al=10h — получили его двоичный эквивалент
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>См. также: уроки 3, 8, приложение 7 и команды <A HREF="#aaa">aaa</A>,
<A HREF="#aam">aam</A>, <A HREF="#aas">aas</A>, <A HREF="#daa">daa</A>,
<A HREF="#das">das</A></FONT>
<BR><A NAME="aam"></A>
<CENTER>
<H2>
AAM</H2></CENTER>

<CENTER><FONT SIZE=+1>(Ascii Adjust after Multiply)</FONT></CENTER>

<CENTER><FONT SIZE=+1>ASCII-коррекция после умножения</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>aam</FONT></TD>
</TR>
</TABLE>
<I><FONT SIZE=+0>Назначение:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>корректировка результата умножения двух неупакованных BCD-чисел;</FONT></LI>

<LI>
<FONT SIZE=+0>преобразование двоичного числа меньшего 63h (99<SUB>10</SUB>)
в его неупакованный BCD-эквивалент.</FONT></LI>
</UL>
<I><FONT SIZE=+0><A HREF="../Pic/P_2_4.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>разделить значение регистра al на 10;</FONT></LI>

<LI>
<FONT SIZE=+0>записать частное в регистр ah, остаток — в регистр al.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>r&nbsp;</TD>

<TD>r&nbsp;</TD>

<TD>r&nbsp;</TD>

<TD>r&nbsp;</TD>

<TD>?</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду aam используют для коррекции результата умножения
двух неупакованных BCD-чисел. Специальной команды умножения BCD-чисел нет.
Поэтому BCD-числа умножаются поразрядно, как обычные двоичные числа, командой
mul. Максимальное число, которое получается при таком умножении, — это
9*9=81<SUB>10</SUB>=51<SUB>16</SUB>. Отсюда понятно, что значения, для
которых командой aam можно получить их двузначный BCD-эквивалент в регистре
ax, находятся в дипазоне от 00h до 51h. Эту команду можно применять и для
преобразования двоичного числа из регистра ax (в диапазоне от 0 до 63h)
в его десятичный эквивалент(соответственно, из диапазона от 0 до 99<SUB>10</SUB>).</FONT>

<P><FONT SIZE=+0>Пример 1. Умножить десятичное число 8 на 9. Подготовить
результат к выводу на экран.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,08h&nbsp; ;ah=08h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,09h&nbsp; ;al= 09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul&nbsp;&nbsp;&nbsp;&nbsp; ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;al=48h — двоичный эквивалент 72
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ah=07h,al=02h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ax,3030h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ax=3732h — ASCII-представление числа 72</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Пример 2. Преобразовать двоичное число 60h в эквивалентное
десятичное число.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;поместим число 60h в регистр ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,60h&nbsp; ;ax=60h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aаm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ax=0906h — получили десятичный эквивалент числа 60h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ax,3030h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;символьный эквивалент, можно выводить на экран</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, приложение 7 и команды <A HREF="#aaa">aaa</A>,
<A HREF="#aad">aad</A>, <A HREF="#aas">aas</A>, <A HREF="#daa">daa</A>,
<A HREF="#das">das</A></FONT>
<BR><A NAME="aas"></A>
<CENTER>
<H2>
AAS</H2></CENTER>

<CENTER><FONT SIZE=+1>(Ascii Adjust after Substraction)</FONT></CENTER>

<CENTER><FONT SIZE=+1>ASCII-коррекция после вычитания</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>aas&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> корректировка результата вычитания двух
неупакованных одноразрядных BCD-чисел.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_5.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>если (младший полубайт регистра al меньше 9) или (флаг
af=1), то выполнить следующие действия:</FONT>
<UL>
<LI>
<FONT SIZE=+0>уменьшить значение младшего полубайта регистра al на 6;</FONT></LI>

<LI>
<FONT SIZE=+0>обнулить значение старшего полубайта регистра al;</FONT></LI>

<LI>
<FONT SIZE=+0>установить флаги af и cf в 1;</FONT></LI>
</UL>
<FONT SIZE=+0>иначе установить флаги af и cf в 1.</FONT>

<P><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>?&nbsp;</TD>

<TD>?&nbsp;</TD>

<TD>r</TD>

<TD>?&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду aas используют для коррекции результата вычитания
двух неупакованных одноразрядных BCD-чисел после команды sub. Операндами
в команде sub должны быть правильные одноразрядные BCD-числа. Рассмотрим
возможные варианты вычитания одноразрядных BCD-чисел:</FONT>
<UL>
<LI>
<FONT SIZE=+0>5-9 — для вычитания необходимо сделать заем в старшем разряде.
Факт такого заема в микропроцессоре фиксируется установкой флагов cf и
af в 1 и вычитанием 1 из содержимого ah. В результате после команды aas
в регистре al получается правильное значение (модуль результата), которое
для нашего примера (с учетом заема из старшего разряда) составляет 6. Одновременно
моделируется заем из старшего разряда, что позволяет производить вычитание
длинных чисел.</FONT></LI>

<LI>
<FONT SIZE=+0>8-6 — для вычитания нет необходимости делать заем в старшем
разряде. Поэтому производится сброс флагов cf и af в 0, а ah не изменяется.
В результате после команды aas в регистре al получается правильное значение
(модуль результата), которое для нашего примера составляет 2.</FONT></LI>
</UL>
<FONT SIZE=+0>Пример 1. Вычесть десятичное число 8 из 5. Подготовить результат
к выводу на экран.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,05h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl,08h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; al,bl&nbsp;&nbsp; ;al=0fdh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aas&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;al=07, cf=af=1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,30h&nbsp; ;al=37h — код символа 7
;вывод результата на экран
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dl,al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также: </I>уроки 3, 8, приложение 7 и команды <A HREF="#aaa">aaa</A>,
<A HREF="#aad">aad</A>, <A HREF="#aam">aam</A>, <A HREF="#daa">daa</A>,
<A HREF="#das">das</A></FONT>
<BR><A NAME="adc"></A>
<CENTER>
<H2>
ADC</H2></CENTER>

<CENTER><FONT SIZE=+1>(Addition with Carry)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сложение с переносом</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>adc приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> сложение двух операндов с учетом переноса
из младшего разряда.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_6.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>сложить два операнда;</FONT></LI>

<LI>
<FONT SIZE=+0>поместить результат в первый операнд: приемник=приемник+источник;</FONT></LI>

<LI>
<FONT SIZE=+0>в зависимости от результата установить флаги.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>02</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда adc используется при сложении длинных двоичных
чисел. Ее можно использовать как самостоятельно, так и совместно с командой
add. При совместном использовании команды adc с командой add сложение младших
байтов/слов/двойных слов осуществляется командой add, а уже старшие байты/слова/двойные
слова складываются командой adc, учитывающей переносы из младших разрядов
в старшие. Таким образом, команда adc значительно расширяет диапазон значений
складываемых чисел. В приложении 7 приведен пример программы сложения двоичных
чисел произвольной размерности.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.data
sl1&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01fe544fh
sl2&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 005044cdh
elderREZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 ;для учета переноса из старшего разряда результата
rez&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,sl1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; ax,sl2&nbsp; ;сложение младших слов слагаемых
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; rez,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,sl+2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc&nbsp;&nbsp;&nbsp;&nbsp; ax,sl2+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сложение старших слов слагаемых плюс cf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; rez+2,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc&nbsp;&nbsp;&nbsp;&nbsp; elderREZ,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;учесть возможный перенос
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, приложение 7 и команды <A HREF="#add">add</A>,
<A HREF="#sub">sub</A>, <A HREF="#sbb">sbb</A>, <A HREF="#xadd">xadd</A></FONT>
<BR><A NAME="add"></A>
<CENTER>
<H2>
ADD</H2></CENTER>

<CENTER><FONT SIZE=+1>(ADDition)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сложение</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>add приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> сложение двух операндов источник и приемник
размерностью байт, слово или двойное слово.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_7.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>сложить операнды источник и приемник;</FONT></LI>

<LI>
<FONT SIZE=+0>записать результат сложения в приемник;</FONT></LI>

<LI>
<FONT SIZE=+0>установить флаги.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда add используется для сложения двух целочисленных
операндов. Результат сложения помещается по адресу первого операнда. Если
результат сложения выходит за границы операнда приемник (возникает переполнение),
то учесть эту ситуацию следует путем анализа флага cf и последующего возможного
применения команды adc. Например, сложим значения в регистре ax и области
памяти ch. При сложении следует учесть возможность переполнения.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">chiclo&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2015
rez&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; ax,chislo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;(ax)=(ax)+ch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr rez,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnc&nbsp;&nbsp;&nbsp;&nbsp; dop_sum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если результат не вышел за разрядную сетку
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc&nbsp;&nbsp;&nbsp;&nbsp; word ptr rez+2,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;расширить результат, для учета переноса
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;в старший разряд
dop_sum:
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, Приложение 7 и команды <A HREF="#adc">adc</A>,
<A HREF="#sub">sub</A>, <A HREF="#sbb">sbb</A>, <A HREF="#xadd">xadd</A></FONT>
<BR><A NAME="and"></A>
<CENTER>
<H2>
AND</H2></CENTER>

<CENTER><FONT SIZE=+1>(logical AND)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Логическое И</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>and приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> операция логического умножения для операндов
приемник и источник размерностью байт, слово или двойное слово.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_8.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>выполнить операцию логического умножения над операндами источник
и приемник: каждый бит результата равен 1, если соответствующие биты операндов
равны 1, в остальных случаях бит результата равен 0;</FONT></LI>

<LI>
<FONT SIZE=+0>записать результат операции в приемник;</FONT></LI>

<LI>
<FONT SIZE=+0>установить флаги.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>0</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда and используется для логического умножения двух
операндов. Результат операции помещается по адресу первого операнда. Эту
команду удобно использовать для принудительной установки или сброса определенных
битов операнда.</FONT>
<BR><FONT SIZE=+0>Например, преобразуем двузначное упакованное BCD-число
в его символьный эквивалент.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">u_BCD&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25h ;упакованное BCD-число
s_ch&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 ;место для результата
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; ax,ax&nbsp;&nbsp; ;очистка ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,u_BCD
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp; ax,4&nbsp;&nbsp;&nbsp; ;ax=0250
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,u_BCD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ax=0225
;преобразование в символьное представление:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; ax,3f3fh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ax=3235h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; s_ch,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 9, 12 и команды <A HREF="#or">or</A>,
<A HREF="#xor">xor</A>, <A HREF="#test">test</A></FONT>
<BR><A NAME="bound"></A>
<CENTER>
<H2>
BOUND</H2></CENTER>

<CENTER><FONT SIZE=+1>(check array BOUNDs)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Контроль нахождения индекса массива в границах</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>bound индекс,границы массива&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> проверка нахождения значения индекса в
границах массива.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_9.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>Cравнить значение в регистре индекс с двумя значениями,
расположенными последовательно в ячейке памяти, адресуемой операндом границы
массива. Диапазон значений индекса определяется используемым регистром
индекс:</FONT>
<UL>
<LI>
<FONT SIZE=+0>если это 16-разрядный регистр общего назначения, то содержащееся
в нем значение проверяется на попадание в диапазон значений, которые находятся
в двух последовательных словах в памяти по адресу, указываемому вторым
операндом. Эти два значения являются, соответственно, значениями нижнего
и верхнего индекса границы массива;</FONT></LI>

<LI>
<FONT SIZE=+0>если это 32-разрядный регистр общего назначения, то содержащееся
в нем значение проверяется на попадание в диапазон значений, которые находятся
в двух последовательных двойных словах в памяти по адресу, указываемому
вторым операндом. Эти два значения являются, соответственно, значениями
нижнего и верхнего индекса границы массива;</FONT></LI>
</UL>
<FONT SIZE=+0>Если в результате проверки значение из регистра вышло за
пределы указанного диапазона значений, то возбуждается прерывание с номером
5, если нет, программа продолжает выполнение.</FONT>

<P><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>

<TD>
<CENTER>&nbsp;</CENTER>
</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду bound очень удобно использовать для контроля
выхода за нижнюю или верхнюю границы массива. Значения этих границ должны
быть предварительно помещены в два последовательных слова (двойных слова)
в памяти. Адрес этих слов (двойных слов) указывается вторым операндом.
Далее динамически в ходе работы программы значение в регистре индекс, указываемом
первым операндом, сравнивается со значениями этих двух границ, и если нижняя_граница&lt;=(индексindex)&lt;=верхняя_граница,
то программа продолжает выполнение. В противном случае генерируется исключительная
ситуация 5 (int 5). Далее в программе обработки этой ситуации можно выполнить
необходимую корректировку и вернуться в программу (см. урок 17).</FONT>

<P><FONT SIZE=+0>Фрагмент, который можно использовать при обработке одномерного
массива с размерностью элементов в слово:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286&nbsp;&nbsp;&nbsp; ;это обязательная директива, так как bound
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;входит в систему команд микропроцессоров, начиная с i286
.data
BoundMas&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label&nbsp;&nbsp; word
Low_Bound&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
Upp_Bound&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20
mas&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 dup (?)
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; di,di&nbsp;&nbsp; ;очистка индексного регистра
cycl:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,mas[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;перебор
элементов массива
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; di,2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bound&nbsp;&nbsp; di,BoundMas
;если значение в di не будет попадать в границы, то будет вызван
;обработчик прерывания 5, где можно скорректировать
;значение ip/eip в стеке с тем, чтобы выйти
;из бесконечного ;цикла, например, на метку М2 или
;выполнить другие действия
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; cycl
М2:
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 17 и команду <A HREF="#iret">iret/iretd</A></FONT>
<BR><A NAME="bsf"></A>
<CENTER>
<H2>
BSF</H2></CENTER>

<CENTER><FONT SIZE=+1>(Bit Scan Forward)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Побитное сканирование вперед</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>bsf результат,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> для проверки наличия единичных битов в
операнде источник.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_10.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>просмотр битов операнда источник, начиная с бита 0 и заканчивая
битом 15/31, до тех пор, пока не встретится единичный бит;</FONT></LI>

<LI>
<FONT SIZE=+0>если встретился единичный бит, то флаг zf устанавливается
в 0 и в регистр первого операнда записывается номер позиции, где встретился
единичный бит. Диапазон значений зависит от разрядности второго операнда:
для 16-разрядного операнда — это 0...15; для 32-разрядного — это 0...31;</FONT></LI>

<LI>
<FONT SIZE=+0>если единичных битов нет, то флаг zf устанавливается в 1.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>06</TD>
</TR>

<TR>
<TD>ZF</TD>
</TR>

<TR>
<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду bsf используют при работе на битном уровне для
определения позиции в операнде крайних справа единичных битов.</FONT>
<BR><FONT SIZE=+0>Например, сдвинем содержимое регистра bx вправо таким
образом, чтобы нулевой бит стал единичным:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,0002h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;bx=0000 0010b
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsf&nbsp;&nbsp;&nbsp;&nbsp; cx,bx&nbsp;&nbsp; ;cx=0001h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shr&nbsp;&nbsp;&nbsp;&nbsp; bx,cl&nbsp;&nbsp; ;bx=0000 0001b
...
null:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 9, 12 и команду <A HREF="#bsr">bsr</A></FONT>
<BR><A NAME="bsr"></A>
<CENTER>
<H2>
BSR</H2></CENTER>

<CENTER><FONT SIZE=+1>(Bit Scan Reverse)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Побитное сканирование назад</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>bsr результат,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> проверка наличия единичных битов в операнде
источник.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_11.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>просмотр битов операнда источник, начиная со старшего бита
15/31 и заканчивая битом 0, до тех пор, пока не встретится единичный бит;</FONT></LI>

<LI>
<FONT SIZE=+0>если встретился единичный бит, флаг zf устанавливается в
0 и в регистр первого операнда записывается номер позиции (отсчет осуществляется
относительно нулевой позиции), где встретился самый старший единичный бит.
Диапазон значений зависит от разрядности второго операнда: для 16-разрядного
операнда это 0...15; для 32-разрядного — 0...31;</FONT></LI>

<LI>
<FONT SIZE=+0>если единичных битов нет, флаг zf устанавливается в 1.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>06</TD>
</TR>

<TR>
<TD>ZF</TD>
</TR>

<TR>
<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду bsr используют при работе на битном уровне для
определения позиции крайних слева единичных битов.</FONT>

<P><FONT SIZE=+0>Например, сдвинем содержимое регистра bx вправо таким
образом, чтобы старший единичный бит исходного значения в bx переместился
в нулевую позицию:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,41h
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsr&nbsp;&nbsp;&nbsp;&nbsp; cx,bx&nbsp;&nbsp; ;cx=06h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shr&nbsp;&nbsp;&nbsp;&nbsp; bx,ax&nbsp;&nbsp; ;bx=0001h
...
null:...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 9, 12 и команду <A HREF="#bsf">bsf</A></FONT>
<BR><A NAME="bswap"></A>
<CENTER>
<H2>
BSWAP</H2></CENTER>

<CENTER><FONT SIZE=+1>(Byte SWAP)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Перестановка байтов</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>bswap источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I><FONT SIZE=+0>Назначение:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>изменение порядка следования байтов;</FONT></LI>

<LI>
<FONT SIZE=+0>переход от одной формы адресации к другой.</FONT></LI>
</UL>
<FONT SIZE=+0>Под формой адресации здесь понимается принцип "младший байт
по младшему адресу" или обратный ему. Существует ряд систем, например использующих
микропроцессоры Motorola или большие ЭВМ, где применяется принцип размещения
многобайтовых значений обратный тому, который используется в микропроцессорах
Intel. Поэтому эту команду можно использовать для разработки программ-конверторов
между подобными платформами и IBM РС.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_12.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><FONT SIZE=+0><I>Алгоритм работы:</I> <I><A HREF="../Pic/P_2_13.gif" TARGET="M2">Схема
алгоритма</A></I></FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду bswap используют для изменения формы адресации.
В качестве операнда может быть указан только 32-разрядный регистр. Эта
команда используется в моделях микропроцессоров, начиная с i486.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.486
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ebx,1a2c345fhh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bswap&nbsp;&nbsp; ebx&nbsp;&nbsp;&nbsp;&nbsp; ;ebx=5f342c1ah
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 7, и команду <A HREF="#xchg">xchg</A></FONT>
<BR><A NAME="bt"></A>
<CENTER>
<H2>
BT</H2></CENTER>

<CENTER><FONT SIZE=+1>(Bit Test)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Проверка битов</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>bt источник,индекс&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> извлечение значения заданного бита в флаг
cf.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_14.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>получить бит по указанному номеру позиции в операнде источник;</FONT></LI>

<LI>
<FONT SIZE=+0>установить флаг cf согласно значению этого бита.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>00</TD>
</TR>

<TR>
<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду bt используют для определения значения конкретного
бита в операнде источник. Номер проверяемого бита задается содержимым второго
операнда (значение числом из диапазона 0...31). После выполнения команды,
флаг cf устанавливается в соответствии со значением проверяемого бита.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ebx,01001100h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,8&nbsp;&nbsp; ;проверка состояния бита 8 и установка cf= в 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;перейти на m1, если проверяемый бит равен 1
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 9, 12 и команды <A HREF="#btc">btc</A>,
<A HREF="#btr">btr</A>, <A HREF="#bts">bts</A>, <A HREF="#test">test</A></FONT>
<BR><A NAME="btc"></A>
<CENTER>
<H2>
BTC</H2></CENTER>

<CENTER><FONT SIZE=+1>(Bit Test and Complement)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Проверка бита с инверсией (дополнением)</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>btc источник,индекс&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> извлечение значения заданного бита в флаг
cf и изменение его значения в операнде на обратное.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_15.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>получить значение бита с номером позиции индекс в операнде
источник;</FONT></LI>

<LI>
<FONT SIZE=+0>инвертировать значение выбранного бита в операнде источник;</FONT></LI>

<LI>
<FONT SIZE=+0>установить флаг сf исходным значением бита.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>00</TD>
</TR>

<TR>
<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда btс используется для определения и инвертирования
значения конкретного бита в операнде источник. Номер проверяемого бита
задается содержимым второго операнда индекс (значение из диапазона 0...31).
После выполнения команды флаг cf устанавливается в соответствии с исходным
значением бита, то есть тем, которое было до выполнения команды.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ebx,01001100h
;проверка состояния бита 8 и его обращение:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; btc&nbsp;&nbsp;&nbsp;&nbsp; ebx,8&nbsp;&nbsp; ;cf=1 и ebx=01001000h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 9, 12 и команды <A HREF="#bt">bt</A>,
<A HREF="#btr">btr</A>, <A HREF="#bts">bts</A>, <A HREF="#test">test</A></FONT>
<BR><A NAME="btr"></A>
<CENTER>
<H2>
BTR</H2></CENTER>

<CENTER><FONT SIZE=+1>(Bit Test and Reset)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Проверка бита с его сбросом в 0</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>btr источник,индекс&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> извлечение значения заданного бита в флаг
cf и изменение его значения на нулевое.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_16.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>получить значение бита с указанным номером позиции в операнде
источник;</FONT></LI>

<LI>
<FONT SIZE=+0>установить флаг cf значением выбранного бита;</FONT></LI>

<LI>
<FONT SIZE=+0>установить значение исходного бита в операнде в 0.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>00</TD>
</TR>

<TR>
<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда btr используется для определения значения конкретного
бита в операнде источник и его сброса в 0. Номер проверяемого бита задается
содержимым второго операнда индекс (значение из диапазона 0...31). В результате
выполнения команды флаг cf устанавливается в соответствии со значением
исходного бита, то есть тем, что было до выполнения операции.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ebx,01001100h
;проверка состояния бита 8 и его сброс в 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; btr&nbsp;&nbsp;&nbsp;&nbsp; ebx,8&nbsp;&nbsp; ;cf=1 и ebx=01001000h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 9, 12 и команды <A HREF="#bt">bt</A>,
<A HREF="#btc">btc</A>, <A HREF="#bts">bts</A>, <A HREF="#test">test</A></FONT>
<BR><A NAME="bts"></A>
<CENTER>
<H2>
BTS</H2></CENTER>

<CENTER><FONT SIZE=+1>(Bit Test and Set)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Проверка бита с его установкой в 1</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>bts источник,индекс&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> извлечение значения заданного бита операнда
в флаг cf и установка этого бита в единицу.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_17.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>получить значение бита с указанным номером позиции в операнде
источник;</FONT></LI>

<LI>
<FONT SIZE=+0>установить флаг cf значением выбранного бита;</FONT></LI>

<LI>
<FONT SIZE=+0>установить значение исходного бита в операнде источник в
1.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>00</TD>
</TR>

<TR>
<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда bts используется для определения значения конкретного
бита в операнде источник и установки проверяемого бита в 1. Номер проверяемого
бита задается содержимым второго операнда индекс (значение из диапазона
0...31). После выполнения команды флаг cf устанавливается в соответствии
со значением исходного бита, то есть тем, что было до выполнения операции.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ebx,01001100h
;проверка состояния бита 0 и его установка в 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bts&nbsp;&nbsp;&nbsp;&nbsp; ebx,0&nbsp;&nbsp; ;cf=0 ebx=01001001h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 9, 12 и команды <A HREF="#bt">bt</A>,
<A HREF="#btc">btc</A>, <A HREF="#btr">btr</A>, <A HREF="#test">test</A></FONT>
<BR><A NAME="call"></A>
<CENTER>
<H2>
CALL</H2></CENTER>

<CENTER><FONT SIZE=+1>(CALL)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Вызов процедуры или задачи</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>call цель&nbsp;</FONT></TD>
</TR>
</TABLE>
<I><FONT SIZE=+0>Назначение:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>передача управления близкой или дальней процедуре с запоминанием
в стеке адреса точки возврата;</FONT></LI>

<LI>
<FONT SIZE=+0>переключение задач.</FONT></LI>
</UL>
<I><FONT SIZE=+0><A HREF="../Pic/P_2_18.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>определяется типом операнда:</FONT>
<UL>
<LI>
<FONT SIZE=+0>метка ближняя — в стек заносится содержимое указателя команд
eip/ip и в этот же регистр загружается новое значение адреса, соответствующее
метке;</FONT></LI>

<LI>
<FONT SIZE=+0>метка дальняя — в стек заносится содержимое указателя команд
eip/ip и cs. Затем в эти же регистры загружаются новые значения адресов,
соответствующие дальней метке;</FONT></LI>

<LI>
<FONT SIZE=+0>r16, 32 или m16, 32 — определяют регистр или ячейку памяти,
содержащие смещения в текущем сегменте команд, куда передается управление.
При передаче управления в стек заносится содержимое указателя команд eip/ip;</FONT></LI>

<LI>
<FONT SIZE=+0>указатель на память — определяет ячейку памяти, содержащую
4 или 6-байтный указатель на вызываемую процедуру. Структура такого указателя
2+2 или 2+4 байта. Интерпретация такого указателя зависит от режима работы
микропроцессора:</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>в реальном режиме — в зависимости от размера адреса (use16
или use32) первые два байта трактуются как сегментный адрес, вторые два/четыре
байта, как смещение целевой метки передачи управления. В стеке запоминается
содержимое регистров cs и eip/ip;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>в защищенном режиме — интерпретация цели передачи управления
зависит от значения байта AR дескриптора, определяемого селекторной частью
указателя. Целью здесь являются дальний вызов процедуры без изменения уровня
привилегий, дальний вызов процедуры с изменением уровня привилегий или
переключение задачи.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды (кроме переключения
задачи):</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0>При <I>переключении задачи</I> значения флажков изменяются
в соответствии с информацией о регистре eflags в сегменте состояния TSS
задачи, на которую производится переключение.</FONT>
<BR><I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Как видно из описания алгоритма, команда call позволяет
организовать гибкую и многовариантную передачу управления на подпрограмму
с сохранением адреса точки возврата. Подробно типовые примеры использования
рассмотрены на уроках 10 и 14.</FONT>
<BR><FONT SIZE=+0><I>См. также:</I> уроки 10, 14 и команду <I><A HREF="#ret">ret</A></I></FONT>
<BR><A NAME="cbw"></A>
<CENTER>
<H2>
CBW/CWDE</H2></CENTER>

<CENTER><FONT SIZE=+1>(Convert Byte to Word/Convert Word to Double Word
Extended)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Преобразование байта в слово/слова в двойное слово</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cbw</FONT>&nbsp;
<BR><FONT SIZE=+0>cwde&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> расширение операнда со знаком.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_19.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>cbw — при работе команда использует только регистры al
и ax:</FONT>
<UL>
<LI>
<FONT SIZE=+0>анализ знакового бита регистра al:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>если знаковый бит al=0, то ah=00h;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>если знаковый бит al=1, то ah=0ffh.</FONT></LI>
</UL>
</UL>
<FONT SIZE=+0>cwde — при работе команда использует только регистры ax и
eax:</FONT>
<UL>
<LI>
<FONT SIZE=+0>анализ знакового бита регистра ax:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>если знаковый бит ax=0, то установить старшее слово eax=0000h;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>если знаковый бит ax=1, то установить старшее слово eax=0ffffh.</FONT></LI>
</UL>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Данные команды используются для приведения операндов
к нужной размерности с учетом знака. Такая необходимость может, в частности,
возникнуть при программировании арифметических операций.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386&nbsp;&nbsp;&nbsp; ;только для cwde, cwd была для i8086
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ebx,10fecd23h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,-3&nbsp;&nbsp; ;ax=1111 1111 1111 1101
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwde&nbsp;&nbsp;&nbsp; ;eax=1111 1111 1111 1111 1111 1111 1111 1101
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; eax,ebx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8 и команды <A HREF="#cdq">cdq</A>,
<A HREF="#cwd">cwd</A></FONT>
<BR><A NAME="clc"></A>
<CENTER>
<H2>
CLC</H2></CENTER>

<CENTER><FONT SIZE=+1>(CLear Carry flag)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сброс флага переноса</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>clc&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> сброс флага переноса cf.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_20.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>установка флага cf в ноль.</FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>00</TD>
</TR>

<TR>
<TD>CF</TD>
</TR>

<TR>
<TD>0</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Данная команда используется для сброса флага cf в ноль.
Такая необходимость может возникнуть при работе с командами сдвига, арифметическими
командами либо действиями по индикации обнаружения ошибок и различных ситуаций
в программе.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;cf=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 8, 9 и команды <A HREF="#cmc">cmc</A>,
<A HREF="#stc">stc</A></FONT>
<BR><A NAME="cld"></A>
<CENTER>
<H2>
CLD</H2></CENTER>

<CENTER><FONT SIZE=+1>(CLear Direction flag)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сброс флага направления</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cld&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> сброс в ноль флага направления df.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_21.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>установка флага df в ноль.</FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>10</TD>
</TR>

<TR>
<TD>DF</TD>
</TR>

<TR>
<TD>0</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Данная команда используется для сброса флага df в ноль.
Такая необходимость может возникнуть при работе с цепочечными командами.
Нулевое занчение флага df вынуждает микропроцессор при выполнении цепочечных
операций производить инкремент регистров si и di.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;df=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 11 и команды <A HREF="#stc">stc</A>,
<A HREF="#movs">movs/movsb/movsw/movsd</A>,</FONT>
<BR><FONT SIZE=+0><A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>, <A HREF="#scas">scas/scasb/scasw/scasd</A>,</FONT>
<BR><FONT SIZE=+0><A HREF="#lods">lods/lodsb/lodsw/lodsd</A>, <A HREF="#stos">stos/stosb/stosw/stosd</A>,</FONT>
<BR><FONT SIZE=+0><A HREF="#ins">ins/insb/insw/insd</A>, <A HREF="#outs">outs</A></FONT>
<BR><A NAME="cli"></A>
<CENTER>
<H2>
CLI</H2></CENTER>

<CENTER><FONT SIZE=+1>(CLear Interrupt flag)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сброс флага прерывания</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cli&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> сброс флага прерывания if.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_22.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>установка флага if в ноль.</FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>09</TD>
</TR>

<TR>
<TD>IF</TD>
</TR>

<TR>
<TD>0</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Данная команда используется для сброса флага if в ноль.
Такая необходимость может возникнуть при разработке программ обработки
прерываний.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cli&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;if=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 15 и команды <A HREF="#int">int</A>,
<A HREF="#iret">iret/iretd</A>, <A HREF="#sti">sti</A></FONT>
<BR><A NAME="cmc"></A>
<CENTER>
<H2>
CMC</H2></CENTER>

<CENTER><FONT SIZE=+1>(CoMplement Carry flag)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Инвертирование флага переноса</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cmc&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> изменение значения флага переноса cf на
обратное.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_23.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>инвертирование значения флага переноса cf.</FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>00</TD>
</TR>

<TR>
<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Данная команда используется для изменения значения флага
cf на противоположное. В частности, этот флаг можно использовать для связи
с процедурой и по его состоянию судить о результате работы данной процедуры.
После выхода из процедуры этот флаг можно проанализировать командой условного
перехода jc.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">proc1&nbsp;&nbsp; proc
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmc
...
proc1&nbsp;&nbsp; endp
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; proc1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;если cf=1, то переход на m1
...
m1:
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 8, 9, 15 и команды <A HREF="#clc">clc</A>,
<A HREF="#stc">stc</A>, <A HREF="#jcc">jc</A>, <A HREF="#jcc">jnc</A></FONT>
<BR><A NAME="cmp"></A>
<CENTER>
<H2>
CMP</H2></CENTER>

<CENTER><FONT SIZE=+1>(CoMPare operands)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сравнение операндов</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cmp операнд1,операнд2&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> сравнение двух операндов.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_24.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>выполнить вычитание (операнд1-операнд2);</FONT></LI>

<LI>
<FONT SIZE=+0>в зависимости от результата установить флаги, операнд1 и
операнд2 не изменять (то есть результат не запоминать).</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Данная команда используется для сравнения двух операндов
методом вычитания, при этом операнды не изменяются. По результатам выполнения
команды устанавливаются флаги. Команда cmp применяется с командами условного
перехода и командой установки байта по значению setcc.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">len&nbsp;&nbsp;&nbsp;&nbsp; equ&nbsp;&nbsp;&nbsp;&nbsp; 10
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; ax,len
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход если (ax)&lt;>len
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход если (ax)=len
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 10, 11, 12 и команды <A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>,
<A HREF="#cmpxchg">cmpxchg</A>, <A HREF="#sub">sub</A>, <A HREF="#jcc">jcc</A>,
<A HREF="#setcc">setcc</A></FONT>
<BR><A NAME="cmps"></A>
<CENTER>
<H2>
CMPS/CMPSB/CMPSW/CMPSD</H2></CENTER>

<CENTER><FONT SIZE=+1>(CoMPare String Byte/Word/Double word operands)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сравнение строк байтов/слов/двойных слов</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cmps приемник,источник</FONT>&nbsp;
<BR><FONT SIZE=+0>cmpsb</FONT>&nbsp;
<BR><FONT SIZE=+0>cmpsw</FONT>&nbsp;
<BR><FONT SIZE=+0>cmpsd</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> сравнение двух последовательностей (цепочек)
элементов в памяти.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_25.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>выполнить вычитание элементов (источник - приемник), адреса
элементов предварительно должны быть загружены:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>адрес источника — в пару регистров <I>ds</I>:esi/si;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>адрес назначения — в пару регистров es:edi/di;</FONT></LI>
</UL>

<LI TYPE="DISK">
<FONT SIZE=+0>в зависимости от состояния флага df изменить значение регистров
esi/si и edi/di:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>если df=0, то увеличить содержимое этих регистров на длину
элемента последовательности;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>если df=1, то уменьшить содержимое этих регистров на длину
элемента последовательности;</FONT></LI>
</UL>

<LI TYPE="DISK">
<FONT SIZE=+0>в зависимости от результата вычитания установить флаги:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>если очередные элементы цепочек не равны, то cf=1, zf=0;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>если очередные элементы цепочек или цепочки в целом равны,
то cf=0, zf=1;</FONT></LI>
</UL>

<LI TYPE="DISK">
<FONT SIZE=+0>при наличии префикса выполнить определяемые им действия (см.
команды repe/repne).</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команды без префиксов осуществляют простое сравнение
двух элементов в памяти. Размеры сравниваемых элементов зависят от применяемой
команды. Команда cmps может работать с элементами размером в байт, слово,
двойное слово. В качестве операндов в команде указываются идентификаторы
последовательностей этих элементов в памяти. Реально эти идентификаторы
используются лишь для получения типов элементов последовательностей, а
их адреса должны быть предварительно загружены в указанные выше пары регистров.
Транслятор, обработав команду cmps и выяснив тип операндов, генерирует
одну из машинных команд cmpsb, cmpsw или cmpsd. Машинного аналога для команды
cmps нет. Для адресации назначения обязательно должен использоваться регистр
es, а для адресации источника можно делать замену сегмента с использованием
соответствующего префикса.</FONT>
<BR><FONT SIZE=+0>Для того чтобы эти команды можно было использовать для
сравнения последовательности элементов, имеющих размерность байт, слово,
двойное слово, необходимо использовать один из префиксов repe или repne.
Префикс repe заставляет циклически выполняться команды сравнения до тех
пор, пока содержимое регистра <I>ecx/cx</I> не станет равным нулю или пока
не совпадут очередные сравниваемые элементы цепочек (флаг zf=1). Префикс
repne заставляет циклически производить сравнение до тех пор, пока не будет
достигнут конец цепочки (<I>ecx/cx</I>=0) либо не встретятся различающиеся
элементы цепочек (флаг zf=0).</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.data
obl1&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Строка для сравнения'
obl1&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Строка для сравнения'
a_obl1&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obl1
a_obl2&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obl2
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;просмотр цепочки в направлении возрастания адресов
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,20&nbsp;&nbsp; ;длина цепочки
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lds&nbsp;&nbsp;&nbsp;&nbsp; si,a_obl1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;адрес источника в пару ds:si
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; les&nbsp;&nbsp;&nbsp;&nbsp; di,a_obl2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;адрес назначения в пару ds:si
repe&nbsp;&nbsp;&nbsp; cmpsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сравнивать, пока равны
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnz&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;если не конец цепочки, то встретились разные элементы
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;действия, если цепочки совпали
...
m1:
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;действия, если цепочки не совпали
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 10, 11 и команды <I><A HREF="#ins">ins</A></I>,
<I><A HREF="#lods">lods</A></I>, <I><A HREF="#movs">movs</A></I>, <I><A HREF="#outs">outs</A></I>,
<I><A HREF="#scas">scas</A></I>, <I><A HREF="#stos">stos</A></I>, <I><A HREF="#rep">repe</A></I>,
<I><A HREF="#rep">repz</A></I>, <I><A HREF="#rep">repne</A></I>, <I><A HREF="#rep">repnz</A></I></FONT>
<BR><A NAME="cmpxchg"></A>
<CENTER>
<H2>
CMPXCHG</H2></CENTER>

<CENTER><FONT SIZE=+1>(CoMPare and eXCHanGe)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сравнение и обмен</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cmpxchg приемник,источник(аккумулятор)&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> сравнение и обмен значений между источником
и приемником.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_26.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>выполнить сравнение элементов источник и приемник;</FONT></LI>

<LI>
<FONT SIZE=+0>если источник и приемник не равны, то:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>установить zf=0;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>переслать содержимое операнда приемник в источник (регистр
al/ax/eax).</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0>если источник и приемник равны, то:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>установить zf=1;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>переслать содержимое операнда источник (регистр al/ax/eax)
по месту операнда приемник.</FONT></LI>
</UL>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команды сравнивают два операнда. Один из сравниваемых
операндов находится в аккумуляторе (регистре al/ax/eax), другой может находиться
в памяти или регистре общего назначения. Если значения равны, то производится
замена содержимого операнда приемник содержимым источника, находящимся
в регистре-аккумуляторе. Если значения не равны, то производится замена
содержимого операнда источника находящимся в регистре-аккумуляторе содержимым
операнда назначения. Определить тот факт, была ли произведена смена значения
в аккумуляторе (то есть были ли не равны сравниваемые операнды), можно
по значению флага zf.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.486
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,114eh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,8e70h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpxchg bx,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если zf=1, то есть операнды равны
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;и ax не изменился
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;действия, если операнды не равны
m1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 7, 10 и команды <I><A HREF="#cmp">cmp</A></I>,
<I><A HREF="#xchg">xchg</A></I></FONT>
<BR><A NAME="cwd"></A>
<CENTER>
<H2>
CWD</H2></CENTER>

<CENTER><FONT SIZE=+1>(Convert Word to Double word)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Преобразование слова в двойное слово</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cwd&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> расширение слова со знаком до размера
двойного слова со знаком.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_27.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>копирование значения старшего бита регистра ax во все
биты регистра dx. <I>Состояние флагов после выполнения команды:</I></FONT>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда cwd используется для расширения значения знакового
бита в регистре ax на биты регистра dx. Данную операцию, в частности, можно
использовать для подготовки к операции деления, для которой размер делимого
должен быть в два раза больше размера делителя, либо для приведения операндов
к одной размерности в командах умножения, сложения, вычитания.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,25
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div&nbsp;&nbsp;&nbsp;&nbsp; bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8 и команды <A HREF="#cbw">cbw</A>,
<A HREF="#cdq">cdq</A>, <A HREF="#cbw">cwde</A>, <A HREF="#div">div</A>,
<A HREF="#idiv">idiv</A>, <A HREF="#mul">mul</A>, <A HREF="#imul">imul</A>,
<A HREF="#add">add</A>, <A HREF="#adc">adc</A>, <A HREF="#sub">sub</A>,
<A HREF="#sbb">sbb</A></FONT>
<BR><A NAME="cdq"></A>
<CENTER>
<H2>
CDQ</H2></CENTER>

<CENTER><FONT SIZE=+1>(Convert Double word to Quad word)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Преобразование двойного слова в учетверенное слово</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>cdq&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> расширение двойного слова со знаком до
размера учетверенного слова (64 бита) со знаком.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_28.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>копирование значения старшего бита регистра eax на все
биты регистра edx. <I>Состояние флагов после выполнения команды:</I></FONT>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду cdq можно использовать для распространения значения
знакового бита в регистре eax на все биты регистра edx. Данную операцию,
в частности, можно использовать для подготовки к операции деления, для
которой размер делимого должен быть в два раза больше размера делителя.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
delimoe dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
delitel dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,delimoe
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cdq
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; idiv&nbsp;&nbsp;&nbsp; delitel ;частное в eax, остаток в edx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8 и команды <A HREF="#cbw">cbw</A>,
<A HREF="#cwd">cwd</A>, <A HREF="#cbw">cwde</A>, <A HREF="#div">div</A>,
<A HREF="#idiv">idiv</A></FONT>
<BR><A NAME="daa"></A>
<CENTER>
<H2>
DAA</H2></CENTER>

<CENTER><FONT SIZE=+1>(Decimal Adjust for Addition)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Десятичная коррекция после сложения</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>daa&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> коррекция упакованного результата сложения
двух BCD-чисел в упакованном формате.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_29.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>команда работает только с регистром al и анализирует
наличие следующих ситуаций:</FONT>
<UL>
<LI>
<FONT SIZE=+0>Ситуация 1. В результате предыдущей команды сложения флаг
af=1 или значение младшей тетрады регистра al>9. Напомним, что флаг af
устанавливается в 1 в случае переноса двоичной единицы из бита 3 младшей
тетрады в старшую тетраду регистра al (если значение превысило 0fh). Наличие
одного из этих двух признаков говорит о том, что значение младшей тетрады
превысило 9h.</FONT></LI>

<LI>
<FONT SIZE=+0>Ситуация 2. В результате предыдущей команды сложения флаг
сf=1 или значение регистра al>9fh. Напомним, что флаг cf устанавливается
в 1 в случае переноса двоичной единицы в старший бит операнда (если значение
превысило 0ffh в случае регистра al). Наличие одного из этих двух признаков
говорит о том, что значение в регистре al превысило 9fh.</FONT></LI>
</UL>
<FONT SIZE=+0>Если имеет место одна из этих двух ситуаций, то регистр al
корректируется следующим образом:</FONT>
<UL>
<LI>
<FONT SIZE=+0>для ситуации 1 содержимое регистра al увеличивается на 6;</FONT></LI>

<LI>
<FONT SIZE=+0>для ситуации 2 содержимое регистра al увеличивается на 60h;</FONT></LI>

<LI>
<FONT SIZE=+0>если имеют место обе ситуации, то корректировка начинается
с младшей тетрады.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды (в случае, если
были переносы):</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>1</TD>

<TD>r&nbsp;</TD>

<TD>1</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды (в случае, если
переносов не было):</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>0</TD>

<TD>r&nbsp;</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Эту команду следует применять после сложения двух упакованных
BCD-чисел с целью корректировки получающегося двоичного результата сложения
в правильное двузначное десятичное число. После команды daa следует анализировать
состояние флага cf. Если он равен 1, то это говорит о том, что был перенос
единицы в старший разряд и это нужно учесть для сложения старших десятичных
цифр BCD-числа.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,69h&nbsp; ;69h — упакованное BCD-число
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl,74h&nbsp; ;74h — упакованное BCD-число
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc&nbsp;&nbsp;&nbsp;&nbsp; al,bl&nbsp;&nbsp; ;al=0ddh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; daa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;cf=1, al=43h
;если перенос, то переход на ту ветвь программы,
;где он будет учтен:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc m1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, Приложение 7 и команды <A HREF="#aaa">aaa</A>,
<A HREF="#aad">aad</A>, <A HREF="#aam">aam</A>, <A HREF="#aas">aas</A>,
<A HREF="#das">das</A></FONT>
<BR><A NAME="das"></A>
<CENTER>
<H2>
DAS</H2></CENTER>

<CENTER><FONT SIZE=+1>(Decimal Adjust for Subtraction)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Десятичная коррекция после вычитания</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>das&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> коррекция упакованного результата вычитания
двух BCD-чисел в упакованном формате.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_30.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>команда das работает только с регистром al и анализирует
наличие следующих ситуаций:</FONT>
<UL>
<LI>
<FONT SIZE=+0>Ситуация 1. В результате предыдущей команды сложения флаг
af =1 или значение младшей тетрады регистра al>9. Напомним, что для случая
вычитания флаг af устанавливается в 1 в случае заема двоичной единицы из
старшей тетрады в младшую тетраду регистра al. Наличие одного из этих двух
признаков говорит о том, что значение младшей тетрады превысило 9h и его
нужно корректировать.</FONT></LI>

<LI>
<FONT SIZE=+0>Ситуация 2. В результате предыдущей команды сложения флаг
сf =1 или значение регистра al>9fh. Напомним, что для случая вычитания
флаг cf устанавливается в 1 в случае заема двоичной единицы. Наличие одного
из этих двух признаков говорит о том, что значение в регистре al превысило
9fh.</FONT></LI>
</UL>
<FONT SIZE=+0>Если имеет место одна из этих ситуаций, то регистр al корректируется
следующим образом:</FONT>
<UL>
<LI>
<FONT SIZE=+0>для ситуации 1 содержимое регистра al уменьшается на 6;</FONT></LI>

<LI>
<FONT SIZE=+0>для ситуации 2 содержимое регистра al уменьшается на 60h;</FONT></LI>

<LI>
<FONT SIZE=+0>если имеют место обе ситуации, то корректировка начинается
с младшей тетрады.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды (в случае, если
были переносы):</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>1</TD>

<TD>r&nbsp;</TD>

<TD>1</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды (в случае, если
переносов не было):</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>0</TD>

<TD>r&nbsp;</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду das следует применять после вычитания двух упакованных
BCD-чисел с целью корректировки получающегося двоичного результата вычитания
в правильное двузначное десятичное число. После команды das следует анализировать
состояние флага cf. Если он равен 1, то это говорит о том, что был заем
единицы в старший разряд и это нужно учесть в дальнейших действиях. Если
у вычитаемого нет больше старших разрядов, то результат следует трактовать
как отрицательное двоичное дополнение. Для определения его абсолютного
значения нужно вычесть 100 из результата в al. Если у вычитаемого еще есть
старшие разряды, то факт заема нужно просто учесть уменьшением младшего
из этих оставшихся старших разрядов на единицу.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,08h&nbsp; ;ah=08h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,05h&nbsp; ;al=05h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; al,ah&nbsp;&nbsp; ;al=al+ah=05h+08h=0dh — не BCD-число
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; ah,ah&nbsp;&nbsp; ;ah=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aaa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ah=01h,al=03h — результат скорректирован
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, Приложение 7 и команды <A HREF="#aaa">aaa</A>,
<A HREF="#aad">aad</A>, <A HREF="#aam">aam</A>, <A HREF="#aas">aas</A>,
<A HREF="#daa">daa</A></FONT>
<BR><A NAME="dec"></A>
<CENTER>
<H2>
DEC</H2></CENTER>

<CENTER><FONT SIZE=+1>(DECrement operand by 1)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Уменьшение операнда на единицу</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>dec операнд&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> уменьшение значения операнда в памяти
или регистре на 1.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_31.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>команда вычитает 1 из операнда. <I>Состояние флагов после
выполнения команды:</I></FONT>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда dec используется для уменьшения значения байта,
слова, двойного слова в памяти или регистре на единицу. При этом заметьте
то, что команда не воздействует на флаг cf.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,9
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp; al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;al=8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8 и команды <I><A HREF="#inc">inc</A></I>,
<I><A HREF="#sub">sub</A></I></FONT>
<BR><A NAME="div"></A>
<CENTER>
<H2>
DIV</H2></CENTER>

<CENTER><FONT SIZE=+1>(DIVide unsigned)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Деление беззнаковое</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>div делитель&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> выполнение операции деления двух двоичных
беззнаковых значений.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_32.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>Для команды необходимо задание двух операндов — делимого
и делителя. Делимое задается неявно и размер его зависит от размера делителя,
который указывается в команде:</FONT>
<UL>
<LI>
<FONT SIZE=+0>если делитель размером в байт, то делимое должно быть расположено
в регистре ax. После операции частное помещается в al, а остаток — в ah;</FONT></LI>

<LI>
<FONT SIZE=+0>если делитель размером в слово, то делимое должно быть расположено
в паре регистров dx:ax, причем младшая часть делимого находится в ax. После
операции частное помещается в ax, а остаток — в dx;</FONT></LI>

<LI>
<FONT SIZE=+0>если делитель размером в двойное слово, то делимое должно
быть расположено в паре регистров edx:eax, причем младшая часть делимого
находится в eax. После операции частное помещается в eax, а остаток — в
edx.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?&nbsp;</TD>

<TD>?</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда выполняет целочисленное деление операндов с выдачей
результата деления в виде частного и остатка от деления. При выполнении
операции деления возможно возникновение исключительной ситуации: 0 — ошибка
деления. Эта ситуация возникает в одном из двух случаев: делитель равен
0 или частное слишком велико для его размещения в регистре eax/ax/al.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,10234
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl,154
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div&nbsp;&nbsp;&nbsp;&nbsp; bl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ah=остаток, al=частное
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, приложение 7 и команду <A HREF="#idiv">idiv</A></FONT>
<BR><A NAME="enter"></A>
<CENTER>
<H2>
ENTER</H2></CENTER>

<CENTER><FONT SIZE=+1>(setup parameter block for ENTERing procedure)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Установка кадра стека для параметров процедуры</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>enter loc_size,lex_lev&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> установка границы в стеке для локальных
переменных процедуры.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_33.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>поместить текущее значение регистра ebp/bp в стек;</FONT></LI>

<LI>
<FONT SIZE=+0>сохранить текущее значение esp/sp в промежуточной переменной
fp (имя переменной выбрано случайно);</FONT></LI>

<LI>
<FONT SIZE=+0>если лексический уровень вложенности (операнд lex_lev) не
равен нулю, то (lex_lev–1) раз делать следующее:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>в зависимости от установленного режима адресации use16 или
use32 выполнить вычитание (bp–2) или (ebp–4) и записать результат обратно
в ebp/bp;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>сохранить значение ebp/bp в стеке;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>сохранить в стеке значение промежуточной переменной fp;</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0>записать значение промежуточной переменной fp в регистр ebp/bp;</FONT></LI>

<LI>
<FONT SIZE=+0>уменьшить значение регистра esp/sp на величину, заданную
первым операндом, минус размер области локальных переменных loc_size: esp/sp=(esp/sp)–loc_size.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда enter специально введена в систему команд микропроцессора
для поддержки блочно-структурированных языков высокого уровня типа Pascal
или С. В этих языках программа разбивается на блоки. В блоках можно описать
свои собственные (локальные) идентификаторы, которые не могут быть использованы
вне этого блока. К примеру, на рисунке ниже в виде блоков изображена структура
некоторой программы.</FONT>
<CENTER></CENTER>

<CENTER><IMG SRC="../Pic/P_2_34.gif" NOSAVE HEIGHT=392 WIDTH=340></CENTER>

<CENTER><I><FONT SIZE=+0>Изображение структуры некоторой программы в виде
блоков</FONT></I></CENTER>


<P><FONT SIZE=+0>В правом верхнем углу каждого блока (процедуры) стоит
номер лексического уровня вложенности этого блока относительно других блоков
программы. Большинство блочно-структурированных языков в качестве основного
метода распределения памяти для переменных в блоках используют автоматическое
распределение памяти. Это означает, что при входе в блок (вызове процедуры
и т. п.) в некотором месте памяти (или в стеке) выделяется область памяти
для переменных этого блока (ее можно назвать областью инициализации). После
выхода из этого блока связь программы с этой областью теряется, то есть
эти переменные становятся недоступными. Но если, как в нашем примере, в
этой процедуре есть вложенные блоки (процедуры), то для некоторого внутреннего
блока (например, C) могут быть доступны области инициализации (переменные)
блоков, объемлющих данный блок. В нашем примере для блока C доступны также
переменные блоков B и A, но не D. Возникает вопрос: как же программа, находясь
в конкретной точке своего выполнения, может отслеживать то, какие области
инициализации ей доступны? Это делается с помощью структуры данных, называемой
дисплеем. Дисплей содержит указатели на самую последнюю область текущего
блока и на области инициализации всех блоков, объемлющих данный блок в
программе. Например, если в программе A была вызвана сначала процедура
B, а затем C, то дисплей содержит указатели на области инициализации A,
B и C (см. рисунок ниже).</FONT>
<CENTER></CENTER>

<CENTER><IMG SRC="../Pic/P_2_35.gif" NOSAVE HEIGHT=175 WIDTH=261></CENTER>


<P><FONT SIZE=+0>Если после этого вызвать процедуру D (в то время как B
и C еще не завершены), то картина изменится.</FONT>
<CENTER></CENTER>

<CENTER><IMG SRC="../Pic/P_2_36.gif" NOSAVE HEIGHT=172 WIDTH=257></CENTER>


<P><FONT SIZE=+0>После того как некоторый блок (процедура) завершает свою
работу, ее область инициализации удаляется из памяти (стека) и одновременно
соответствующим образом корректируется дисплей. Большинство языков высокого
уровня хранят локальные данные блоков в стеке. Эти переменные называют
еще автоматическими или динамическими. Память для них резервируется путем
уменьшения значения регистра-указателя стека esp/sp на величину, равную
длине области, занимаемой этими динамическими переменными. Доступ к этим
переменным осуществляется посредством регистра ebp/bp. Если один блок вложен
в другой, то для его динамических (локальных) переменных также выделяется
место (кадр) в стеке, но в этот кадр помещается указатель на кадр стека
для включающего его блока. Команды enter и leave как раз и позволяют поддержать
в языке ассемблера принципы работы с переменными блоков как в блочно-структурированных
языках. Дисплей организуется с помощью второго операнда команды enter и
стека. Например, в начале работы главной процедуры A и после вызова процедуры
B кадр стека будет выглядеть так.</FONT>
<CENTER></CENTER>

<CENTER><IMG SRC="../Pic/P_2_37.gif" NOSAVE HEIGHT=357 WIDTH=637></CENTER>


<P><FONT SIZE=+0>Соответственно, после вызова процедур C и D стек будет
выглядеть, как показано ниже.</FONT>
<CENTER></CENTER>

<CENTER><IMG SRC="../Pic/P_2_38.gif" NOSAVE HEIGHT=619 WIDTH=641></CENTER>


<P><FONT SIZE=+0>Таким образом, видно, что используя дисплей, мы фактически
имеем адреса областей инициализации, доступных по признаку вложенности
объемлющих блоков. Обратный процесс завершения работы с блоками и удаления
соответствующих областей инициализации поддерживается командой leave.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286
proc1&nbsp;&nbsp; proc
;зарезервировать в стеке место для локальных переменных
;proc1 16 байт
;лексический уровень вложенности 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enter&nbsp;&nbsp; 16,0
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leave
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
proc1&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 14 и команды <A HREF="#leave">leave</A>,
<I><A HREF="#ret">ret</A></I></FONT>
<BR><A NAME="hlt"></A>
<CENTER>
<H2>
HLT</H2></CENTER>

<CENTER><FONT SIZE=+1>(HaLT)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Остановка</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>hlt&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> остановка микропроцессора до прерывания
или перезагрузки.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_39.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>перевод микропроцессора в состояние остановки.</FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>В результате выполнения команды микропроцессор переходит
в состояние остановки. Из этого состояния его можно вывести сигналами на
входах RESET, NMI, INTR. Если для возобновления работы микропроцессора
используется прерывание, то сохраненное значение пары cs:eip/ip указывает
на команду, следующую за hlt. Для иллюстрации применения данной команды
рассмотрим еще один способ переключения микропроцессора из защищенного
в реальный режим и его возврата обратно в реальный режим (см. урок 16).
Как известно, в микропроцессоре не предусмотрено специальных средств для
подобного переключения. Сброс микропроцессора можно инициировать, если
вывести байт со значением 0feh в порт клавиатуры 64h. После этого микропроцесор
переходит в реальный режим и управление получает программа BIOS, которая
анализирует байт отключения в CMOS-памяти по адресу 0fh. Для нас интерес
представляют два значения этого байта — 5h и 0ah:</FONT>
<UL>
<LI>
<FONT SIZE=+0>5h — сброс микропроцессора инициирует инициализацию программируемого
контроллера прерываний на значение базового вектора 08h (см. уроки 15 и
17). Далее управление передается по адресу, который находится в ячейке
области данных BIOS 0040:0067;</FONT></LI>

<LI>
<FONT SIZE=+0>0ah — сброс микропроцессора инициирует непосредственно передачу
управления по адресу в ячейке области данных BIOS 0040:0067 (то есть без
перепрограммирования контроллера прерываний).</FONT></LI>
</UL>
<FONT SIZE=+0>Таким образом, если вы не используете прерываний, то достаточно
установить байт 0fh в CMOS-памяти в 0ah. Предварительно, конечно, вы должны
инициализировать ячейку области данных BIOS 0040:0067 значением адреса,
по которому необходимо передать управление после сброса. Для программирования
CMOS-памяти используются номера портов 070h и 071h. Вначале в порт 070h
заносится нужный номер ячейки CMOS-памяти, а затем в порт 071h — новое
значение этой ячейки.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;работаем в реальном режиме, готовимся к переходу
;в защищенный режим:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; es
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,40h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr es:[67h],offset ret_real
;ret_real — метка в программе, с которой должно
;начаться выполнение программы после сброса
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[69h],cs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,0fh&nbsp; ;будем обращаться к ячейке 0fh в CMOS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; 70h,al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; $+2&nbsp;&nbsp;&nbsp;&nbsp; ;чуть задержимся, чтобы аппаратура отработала
;сброс без перепрограммирования контроллера
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,0ah
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; 71h,al
;переходим в защищенный режим установкой
;бита 0 cr0 в 1 (см. урок 16)
;работаем в защищенном режиме
;готовимся перейти обратно в реальный режим
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,01fch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; 64h,al&nbsp; ;сброс микропроцессора&nbsp; hlt
;остановка до физического окончания процесса сброса
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_real:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp; ;метка, на которую будет передано
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;управление после сброса
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 15, 16, 17</FONT>
<BR><A NAME="idiv"></A>
<CENTER>
<H2>
IDIV</H2></CENTER>

<CENTER><FONT SIZE=+1>(Integer DIVide)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Деление целочисленное со знаком</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>idiv делитель&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> операция деления двух двоичных значений
со знаком.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_40.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>Для команды необходимо задание двух операндов — делимого
и делителя. Делимое задается неявно, и размер его зависит от размера делителя,
местонахождение которого указывается в команде:</FONT>
<UL>
<LI>
<FONT SIZE=+0>если делитель размером в байт, то делимое должно быть расположено
в регистре ax. После операции частное помещается в al, а остаток — в ah;</FONT></LI>

<LI>
<FONT SIZE=+0>если делитель размером в слово, то делимое должно быть расположено
в паре регистров dx:ax, причем младшая часть делимого находится в ax. После
операции частное помещается в ax, а остаток — в dx;</FONT></LI>

<LI>
<FONT SIZE=+0>если делитель размером в двойное слово, то делимое должно
быть расположено в паре регистров edx:eax, причем младшая часть делимого
находится в eax. После операции частное помещается в eax, а остаток — в
edx;</FONT></LI>
</UL>
<FONT SIZE=+0>Остаток всегда имеет знак делимого. Знак частного зависит
от состояния знаковых битов (старших разрядов) делимого и делителя.</FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?&nbsp;</TD>

<TD>?</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда выполняет целочисленное деление операндов с учетом
их знаковых разрядов. Результатом деления являются частное и остаток от
деления. При выполнении операции деления возможно возникновение исключительной
ситуации: 0 — ошибка деления. Эта ситуация возникает в одном из двух случаев:
делитель равен 0 или частное слишком велико для его размещения в регистре
eax/ax/al.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;деление слов
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,1045 ;делимое
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,587&nbsp; ;делитель
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;расширение делимого dx:ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; idiv&nbsp;&nbsp;&nbsp; bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;частное в ax, остаток в dx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, приложение 7 и команду <A HREF="#div">div</A></FONT>
<BR><A NAME="imul"></A>
<CENTER>
<H2>
IMUL</H2></CENTER>

<CENTER><FONT SIZE=+1>(Integer MULtiply)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Умножение целочисленное со знаком</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>imul множитель_1</FONT>&nbsp;
<BR><FONT SIZE=+0>imul множ_1,множ_2</FONT>&nbsp;
<BR><FONT SIZE=+0>imul рез-т,множ_1,множ_2</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> операция умножения двух целочисленных
двоичных значений со знаком.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_41.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>Алгоритм работы команды зависит от используемой формы
команды. Форма команды с одним операндом требует явного указания местоположения
только одного сомножителя, который может быть расположен в ячейке памяти
или регистре. Местоположение второго сомножителя фиксировано и зависит
от размера первого сомножителя:</FONT>
<UL>
<LI>
<FONT SIZE=+0>если операнд, указанный в команде, — байт, то второй сомножитель
располагается в al;</FONT></LI>

<LI>
<FONT SIZE=+0>если операнд, указанный в команде, — слово, то второй сомножитель
располагается в ax;</FONT></LI>

<LI>
<FONT SIZE=+0>если операнд, указанный в команде, — двойное слово, то второй
сомножитель располагается в eax.</FONT></LI>
</UL>
<FONT SIZE=+0>Результат умножения для команды с одним операндом также помещается
в строго определенное место, определяемое размером сомножителей:</FONT>
<UL>
<LI>
<FONT SIZE=+0>при умножении байтов результат помещается в ax;</FONT></LI>

<LI>
<FONT SIZE=+0>при умножении слов результат помещается в пару dx:ax;</FONT></LI>

<LI>
<FONT SIZE=+0>при умножении двойных слов результат помещается в пару edx:eax.</FONT></LI>
</UL>
<FONT SIZE=+0>Команды с двумя и тремя операндами однозначно определяют
расположение результата и сомножителей следующим образом:</FONT>
<UL>
<LI>
<FONT SIZE=+0>в команде с двумя операндами первый операнд определяет местоположение
первого сомножителя. На его место впоследствии будет записан результат.
Второй операнд определяет местоположение второго сомножителя;</FONT></LI>

<LI>
<FONT SIZE=+0>в команде с тремя операндами первый операнд определяет местоположение
результата, второй операнд — местоположение первого сомножителя, третий
операнд может быть непосредственно заданным значением размером в байт,
слово или двойное слово.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0>Команда imul устанавливает в ноль флаги of и cf, если размер
результата соответствует регистру назначения. Если эти флаги отличны от
нуля, то это означает, что результат слишком велик для отведенных ему регистром
назначения рамок и необходимо указать больший по размеру регистр для успешного
завершения данной операции умножения. Конкретными условиями сброса флагов
of и cf в ноль являются следующие условия:</FONT>
<UL>
<LI>
<FONT SIZE=+0>для однооперандной формы команды imul регистры ax/dx/edx
являются знаковыми расширениями регистров al/ax/eax;</FONT></LI>

<LI>
<FONT SIZE=+0>для двухоперандной формы команды imul для размещения результата
умножения достаточно размерности указанных регистров назначения r16/r32;</FONT></LI>

<LI>
<FONT SIZE=+0>то же для трехоперандной команды умножения.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда выполняет целочисленное умножение операндов с
учетом их знаковых разрядов. Для выполнения этой операции необходимо наличие
двух сомножителей. Размещение и задание их местоположения в команде зависит
от формы применяемой команды умножения, которая, в свою очередь, определяется
моделью микропроцессора. Так, для микропроцессора i8086 возможна только
однооперандная форма команды, для последующих моделей микропроцессоров
дополнительно можно использовать двух- и трехоперандные формы этой команды.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.486
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,186
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imul&nbsp;&nbsp;&nbsp; eax,bx,8
;если результату не хватило размерности операнда1,
;то перейдем на m1, где скорректируем ситуацию:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8, приложение 7 и команду <A HREF="#mul">mul</A></FONT>
<BR><A NAME="in"></A>
<CENTER>
<H2>
IN</H2></CENTER>

<CENTER><FONT SIZE=+1>(INput operand from port)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Ввод операнда из порта</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>in аккумулятор,ном_порта&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> ввод значения из порта ввода-вывода.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_42.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>Передает байт, слово, двойное слово из порта ввода-вывода
в один из регистров al/ax/eax. Состояние флагов после выполнения команды:
выполнение команды не влияет на флаги.</FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда применяется для прямого управления оборудованием
компьютера посредством портов. Номер порта задается вторым операндом в
виде непосредственного значения или значения в регистре dx. Непосредственным
значением можно задать порт с номером в диапазоне 0-255. При использовании
порта с большим номером используется регистр dx. Размер данных определяется
размерностью первого операнда и может быть байтом, словом, двойным словом.
В качестве примера применения рассмотрим фрагмент обработчика прерывания
от клавиатуры 9. Это прерывание вызывается всякий раз при нажатии любой
клавиши на клавиатуре. Обработчик этого прерывания должен прочитать скан-код
клавиши, подтвердить микропроцессору клавиатуры факт приема скан-кода,
преобразовать этот код в соответствии с клавишами-переключателями и поместить
преобразованный код в буфер клавиатуры, находящийся в области BIOS. Действия
чтения и подтверждения приема скан-кода могут выглядеть, к примеру, так:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,60h&nbsp; ;читаем скан-код
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сохраним его на время
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,61h&nbsp; ;читаем порт 61h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,80h&nbsp; ;старший бит байта из порта 61h в 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; 61h,al&nbsp; ;подтверждаем факт приема скан-кода
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; 61h,al&nbsp; ;восстановили байт в порту 61h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 7 и команды <A HREF="#out">out</A>,
<A HREF="#ins">ins/insb/insw/insd</A>, <A HREF="#outs">outs</A></FONT>
<BR><A NAME="inc"></A>
<CENTER>
<H2>
INC</H2></CENTER>

<CENTER><FONT SIZE=+1>(INCrement operand by 1)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Увеличить операнд на 1</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>inc операнд&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> увеличение значения операнда в памяти
или регистре на 1.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_43.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>команда увеличивает операнд на единицу.</FONT>
<BR><I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда используется для увеличения значения байта, слова,
двойного слова в памяти или регистре на единицу. При этом команда не воздействует
на флаг cf.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;увеличить значение в ax на 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> урок 8 и команды <A HREF="#dec">dec</A>,
<A HREF="#add">add</A>, <A HREF="#adc">adc</A></FONT>
<BR><A NAME="ins"></A>
<CENTER>
<H2>
INS/INSB/INSW/INSD</H2></CENTER>

<CENTER><FONT SIZE=+1>(Input String Byte/Word/Double word operands)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Ввод строк байтов/слов/двойных слов из порта</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>ins приемник,порт</FONT>&nbsp;
<BR><FONT SIZE=+0>insb</FONT>&nbsp;
<BR><FONT SIZE=+0>insw</FONT>&nbsp;
<BR><FONT SIZE=+0>insd</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> ввод из порта в память последовательности
байт, слов, двойных слов.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_44.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>передать данные из порта ввода-вывода, номер которого загружен
в регистр dx, в память по адресу es:edi/di;</FONT></LI>

<LI>
<FONT SIZE=+0>в зависимости от состояния флага df изменить значение регистров
edi/di:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>если df=0, то увеличить содержимое этих регистров на длину
структурного элемента последовательности;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>если df=1, то уменьшить содержимое этих регистров на длину
структурного элемента последовательности;</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0>при наличии префикса выполнить определяемые им действия (см.
команду rep).</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команда вводит данные из порта ввода-вывода, номер которого
загружен в регистр dx, в память по адресу es:edi/di. Сегментная составляющая
адреса должна быть обязательно в регистре es. Замена сегментного регистра
недопустима. Непосредственное задание порта в команде также недопустимо
- для этого используется регистр dx. Размеры вводимых элементов зависят
от применяемой команды. Команда ins может работать с элементами размером
в байт, слово, двойное слово. В качестве операндов в команде указывается
символическое имя ячейки памяти, в которую вводятся элементы из порта ввода-вывода.
Реально это символическое имя используется лишь для получения типа элемента
последовательности, а его адрес должен быть предварительно загружен в пару
регистров es:edi/di. Транслятор, обработав команду ins и выяснив тип операнда,
генерирует одну из машинных команд insb, insw или insd. Машинного аналога
для команды ins нет. Для того чтобы эти команды можно было использовать
для ввода последовательности элементов, имеющих размерность байт, слово,
двойное слово, необходимо использовать префикс rep. Префикс rep заставляет
циклически выполняться команду ввода до тех пор, пока содержимое регистра
<I>ecx/cx</I> не станет равным нулю.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286
;ввести 10 байт из порта 300h (номер порта bgr условно)
;в цепочку байт в памяти по адресу
str_10&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 dup(0)
adr_str dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str_10
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; les&nbsp;&nbsp;&nbsp;&nbsp; di,adr_str
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,300h
rep&nbsp;&nbsp;&nbsp;&nbsp; insb
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 2, 11 и команды <A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>,
<A HREF="#lods">lods/lodsb/lodsw/lodsd</A>, <A HREF="#movs">movs/movsb/movsw/movsd</A>,
<A HREF="#outs">outs</A>, <A HREF="#scas">scas/scasb/scasw/scasd</A>, <A HREF="#stos">stos/stosb/stosw/stosd</A>,
<A HREF="#rep">rep/repe/repz/repne/repnz</A></FONT>
<BR><A NAME="int"></A>
<CENTER>
<H2>
INT</H2></CENTER>

<CENTER><FONT SIZE=+1>(INTerrupt)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Вызов подпрограммы обслуживания прерывания</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>int номер_прерывания&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> вызов подпрограммы обслуживания прерывания
с номером прерывания, заданным операндом команды.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_45.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<UL>
<LI>
<FONT SIZE=+0>записать в стек регистр флагов eflags/flags и адрес возврата.
При записи адреса возврата вначале записывается содержимое сегментного
регистра cs, затем содержимое указателя команд eip/ip;</FONT></LI>

<LI>
<FONT SIZE=+0>сбросить в ноль флаги if и tf;</FONT></LI>

<LI>
<FONT SIZE=+0>передать управление на программу обработки прерывания с указанным
номером. Механизм передачи управления зависит от режима работы микропроцессора
(см. уроки 15 и 17).</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>09</TD>

<TD>08</TD>
</TR>

<TR>
<TD>IF</TD>

<TD>TF</TD>
</TR>

<TR>
<TD>0</TD>

<TD>0&nbsp;</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Как видно из синтаксиса, существуют две формы этой команды:</FONT>
<UL>
<LI>
<FONT SIZE=+0>int 3 — имеет свой индивидуальный код операции 0cch и занимает
один байт. Это обстоятельство делает ее очень удобной для использования
в различных программных отладчиках для установки точек прерывания путем
подмены первого байта любой команды. Микропроцессор, встречая в последовательности
команд команду с кодом операции 0cch, вызывает программу обработки прерывания
с номером вектора 3, которая служит для связи с программным отладчиком.</FONT></LI>

<LI>
<FONT SIZE=+0>Вторая форма команды занимает два байта, имеет код операции
0cdh и позволяет инициировать вызов подпрограммы обработки прерывания с
номером вектора в диапазоне 0–255. Особенности передачи управления, как
было отмечено, зависят от режима работы микропроцессора.</FONT></LI>
</UL>
&nbsp;
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;вызов обработчика аппаратного прерывания 08h из программы:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 08h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 15, 17 и команды <A HREF="#into">into</A>,
<A HREF="#iret">iret/iretd</A></FONT>
<BR><A NAME="into"></A>
<CENTER>
<H2>
INTO</H2></CENTER>

<CENTER><FONT SIZE=+1>(INTerrupt if Overflow)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Прерывание, если переполнение</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>into&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> инициирование прерывания с номером 4,
если установлен флаг of.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_46.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>Проанализировать состояние флага of:</FONT>
<UL>
<LI>
<FONT SIZE=+0>если of=0, то никаких действий производить не нужно — передать
управление на следующую команду;</FONT></LI>

<LI>
<FONT SIZE=+0>если of=1, то дальнейшие действия, как при команде int, то
есть:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>записать в стек регистр флагов eflags/flags и адрес возврата.
При записи адреса возврата вначале записывается содержимое сегментного
регистра cs, затем содержимое указателя команд eip/ip;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>сбросить в ноль флаги if и tf;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>передать управление на программу обработки прерывания с данным
номером. Механизм передачи зависит от режима работы микропроцессора (см.
уроки 15 и 17).</FONT></LI>
</UL>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>09</TD>

<TD>08</TD>
</TR>

<TR>
<TD>IF</TD>

<TD>TF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Свойство этой команды инициировать вызов подпрограммы
обработки прерывания с номером вектора 4 определяет варианты ее применения.
Если предыдущая команда в программе может в результате своей работы установить
флаг переполнения of (к примеру, арифметические команды), то для обнаружения
и обработки такой ситуации можно использовать команду into. Особенности
передачи управления и обработки (корректировки) результата зависят от режима
работы микропроцессора.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.486
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,186
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imul&nbsp;&nbsp;&nbsp; eax,bx,8
;если результату не хватило размерности операнда1,
;то of установится в 1
;исправим ситуацию в обработчике прерывания 3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; into
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 8, 15, 17 и команды <A HREF="#int">int</A>,
<A HREF="#iret">iret/iretd</A>, <A HREF="#imul">imul</A></FONT>
<BR><A NAME="iret"></A>
<CENTER>
<H2>
IRET/IRETD</H2></CENTER>

<CENTER><FONT SIZE=+1>(Interrupt RETurn)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Возврат из прерывания</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>iret</FONT>&nbsp;
<BR><FONT SIZE=+0>iretd&nbsp;</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> используется в той точке программы обработки
прерывания, откуда необходимо вернуть управление прерванной программе.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_47.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы:</FONT></I>
<BR><FONT SIZE=+0>Работа команды зависит от режима работы микропроцесссора:</FONT>
<UL>
<LI>
<FONT SIZE=+0>в реальном режиме команда iret последовательно извлекает
из стека и затем восстанавливает в микропроцессоре содержимое следующих
регистров: eip/ip, cs, eflags/flags. Далее прерванная программа продолжается
с точки прерывания;</FONT></LI>

<LI>
<FONT SIZE=+0>в защищенном режиме действия команды зависят от состояния
флага NT (вложенной задачи) в регистре флагов:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0>если NT=0, то производятся действия по возврату управления
прерванной программе, при этом характер этих действий зависит от соотношения
уровней привилегированности прерванной программы и программы обработки
прерывания;</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>в случае NT=1 производятся действия по переключению задач.</FONT></LI>
</UL>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>10</TD>

<TD>09</TD>

<TD>08</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>DF</TD>

<TD>IF</TD>

<TD>TF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение:</FONT></I>
<BR><FONT SIZE=+0>Команду iret необходимо применять для восстановления
сохраненных командой int регистров флагов, указателя команд и сегментного
регистра кода. Число этих команд в программе обработки прерывания должно
соответствовать количеству точек выхода из нее. Команда iretd используется
в старших моделях микропроцессоров для извлечения из стека и восстановления
32-битных регистров.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">my_int1c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc
;программа обработки прерывания 1Ch
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iret
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>См. также:</I> уроки 15, 17 и команды <A HREF="#int">int</A>,
<A HREF="#into">into</A></FONT>
<BR><A NAME="jcc"></A>
<CENTER>
<H2>
JCC<BR>
JCXZ/JECXZ</H2></CENTER>

<CENTER><FONT SIZE=+1>(Jump if condition)</FONT></CENTER>

<CENTER><FONT SIZE=+1>(Jump if CX=Zero/ Jump if ECX=Zero)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Переход, если выполнено условие</FONT></CENTER>

<CENTER><FONT SIZE=+1>Переход, если CX/ECX равен нулю</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>jcc метка</FONT>&nbsp;
<BR><FONT SIZE=+0>jcxz метка</FONT>&nbsp;
<BR><FONT SIZE=+0>jecxz метка</FONT></TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Назначение:</I> переход внутри текущего сегмента команд
в зависимости от некоторого условия.</FONT>

<P><I><FONT SIZE=+0><A HREF="../Pic/P_2_48.gif" TARGET="M2">Синтаксис</A></FONT></I>
<BR><I><FONT SIZE=+0>Алгоритм работы команд (кроме jcxz/jecxz):</FONT></I>
<BR><FONT SIZE=+0>Проверка состояния флагов в зависимости от кода операции
(оно отражает проверяемое условие):</FONT>
<UL>
<LI>
<FONT SIZE=+0>если проверяемое условие истинно, то перейти к ячейке, обозначенной
операндом;</FONT></LI>

<LI>
<FONT SIZE=+0>если проверяемое условие ложно, то передать управление следующей
команде.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Алгоритм работы команды jcxz/jecxz:</FONT></I>
<BR><FONT SIZE=+0>Проверка условия равенства нулю содержимого регистра
<I>ecx/cx</I>:</FONT>
<UL>
<LI>
<FONT SIZE=+0>если проверяемое условие истинно, то есть содержимое <I>ecx/cx</I>
равно 0, то перейти к ячейке, обозначенной операндом метка;</FONT></LI>

<LI>
<FONT SIZE=+0>если проверяемое условие ложно, то есть содержимое <I>ecx/cx</I>
не равно 0, то передать управление следующей за jcxz/jecxz команде программы.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Состояние флагов после выполнения команды:</FONT></I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>05</TD>

<TD>04</TD>

<TD>03</TD>

<TD>02</TD>

<TD>01</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>0</TD>

<TD>AF</TD>

<TD>0</TD>

<TD>PF</TD>

<TD>1</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>?&nbsp;</TD>

<TD>?&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>r&nbsp;</TD>

<TD>&nbsp;</TD>

<TD>?</TD>

<TD>&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I><FONT SIZE=+0>Применение (кроме jcxz/jecxz):</FONT></I>
<BR><FONT SIZE=+0>Команды условного перехода удобно применять для проверки
различных условий, возникающих в ходе выполнения программы. Как известно,
многие команды формируют признаки результатов своей работы в регистре eflags/flags.
Это обстоятельство и используется командами условного перехода для работы.
Ниже приведены перечень команд условного перехода, анализируемые ими флаги
и соответствующие им логические условия перехода.</FONT>
<TABLE BORDER=2 COLS=3 WIDTH="100%" BGCOLOR="#CFFFFF" >
<TR ALIGN=CENTER>
<TD>Команда</TD>

<TD>Состояние проверяемых флагов</TD>

<TD>Условие перехода</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JA</TD>

<TD>CF = 0 и ZF = 0</TD>

<TD>если выше</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JAE</TD>

<TD>CF = 0</TD>

<TD>если выше или равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JB</TD>

<TD>CF = 1</TD>

<TD>если ниже</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JBE</TD>

<TD>CF = 1 или ZF = 1</TD>

<TD>если ниже или равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JC</TD>

<TD>CF = 1</TD>

<TD>если перенос</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JE</TD>

<TD>ZF = 1</TD>

<TD>если равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JZ</TD>

<TD>ZF = 1</TD>

<TD>если 0</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JG</TD>

<TD>ZF = 0 и SF = OF</TD>

<TD>если больше</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JGE</TD>

<TD>SF = OF</TD>

<TD>если больше или равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JL</TD>

<TD>SF &lt;> OF</TD>

<TD>если меньше</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JLE</TD>

<TD>ZF=1 или SF &lt;> OF</TD>

<TD>если меньше или равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNA</TD>

<TD>CF = 1 и ZF = 1</TD>

<TD>если не выше</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNAE</TD>

<TD>CF = 1</TD>

<TD>если не выше или равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNB</TD>

<TD>CF = 0</TD>

<TD>если не ниже</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNBE</TD>

<TD>CF=0 и ZF=0</TD>

<TD>если не ниже или равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNC</TD>

<TD>CF = 0</TD>

<TD>если нет переноса</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNE</TD>

<TD>ZF = 0</TD>

<TD>если не равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNG</TD>

<TD>ZF = 1 или SF &lt;> OF</TD>

<TD>если не больше</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNGE</TD>

<TD>SF &lt;> OF</TD>

<TD>если не больше или равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNL</TD>

<TD>SF = OF</TD>

<TD>если не меньше</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNLE</TD>

<TD>ZF=0 и SF=OF</TD>

<TD>если не меньше или равно</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNO</TD>

<TD>OF=0</TD>

<TD>если нет переполнения</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNP</TD>

<TD>PF = 0</TD>

<TD>если количество единичных битов результата нечетно (нечетный паритет)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNS</TD>

<TD>SF = 0</TD>

<TD>если знак плюс (знаковый (старший) бит результата равен 0)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JNZ</TD>

<TD>ZF = 0</TD>

<TD>если нет нуля</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JO</TD>

<TD>OF = 1</TD>

<TD>если переполнение</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JP</TD>

<TD>PF = 1</TD>

<TD>если количество единичных битов результата четно (четный паритет)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JPE</TD>

<TD>PF = 1</TD>

<TD>то же, что и JP, то есть четный паритет</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JPO</TD>

<TD>PF = 0</TD>

<TD>то же, что и JNP</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JS</TD>

<TD>SF = 1</TD>

<TD>если знак минус (знаковый (старший) бит результата равен 1)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JZ</TD>

<TD>ZF = 1</TD>

<TD>если ноль</TD>
</TR>
</TABLE>
Логические условия "больше" и "меньше" относятся к сравнениям целочисленных
значений со знаком, а "выше и "ниже" — к сравнениям целочисленных значений
без знака. Если внимательно посмотреть, то у многих команд можно заметить
одинаковые значения флагов для перехода. Это объясняется наличием нескольких
ситуаций, которые могут вызвать одинаковое состояние флагов. В этом случае
с целью удобства ассемблер допускает несколько различных мнемонических
обозначений одной и той же машинной команды условного перехода. Эти команды
ассемблера по действию абсолютно равнозначны, так как это одна и та же
машинная команда. Изначально в микропроцессоре i8086 команды условного
перехода могли осуществлять только короткие переходы в пределах -128...+127
байт, считая от следующей команды. Начиная с микропроцессора i386, эти
команды уже могли выполнять любые переходы в пределах текущего сегмента
команд. Это стало возможным за счет введения в систему команд микропроцессора
дополнительных машинных команд. Для реализации межсегментных переходов
необходимо комбинировать команды условного перехода и команду безусловного
перехода jmp. При этом можно воспользоваться тем, что практически все команды
условного перехода парные, то есть имеют команды, проверяющие обратные
условия.
<BR><I>Применение jcxz/jecxz:</I>
<TABLE BORDER=2 COLS=3 BGCOLOR="#CFFFFF" >
<TR ALIGN=CENTER>
<TD>Команда</TD>

<TD>Состояние флагов в eflags/flags</TD>

<TD>Условие перехода</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JCXZ</TD>

<TD>не влияет</TD>

<TD>если регистр CX=0</TD>
</TR>

<TR ALIGN=CENTER>
<TD>JECXZ</TD>

<TD>не влияет</TD>

<TD>если регистр ECX=0</TD>
</TR>
</TABLE>
Команду jcxz/jecxz удобно использовать со всеми командами, использующими
регистр <I>ecx/cx</I> для своей работы. Это команды организации цикла и
цепочечные команды. Очень важно отметить то, что команда jcxz/jecxz, в
отличие от других команд перехода, может выполнять только близкие переходы
в пределах -128...+127 байт, считая от следующей команды. Поэтому для нее
особенно актуальна проблема передачи управления далее чем в указанном диапазоне.
Для этого можно привлечь команду безусловного перехода jmp. Например, команду
jcxz/jecxz можно использовать для предварительной проверки счетчика цикла
в регистре cx для обхода цикла, если его счетчик нулевой.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jcxz&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;обойти цикл, если cx=0
cycl:
;некоторый цикл
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop&nbsp;&nbsp;&nbsp; cycl
m1:&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 10, 11 и команду <I><A HREF="#jmp">jmp</A></I>
<BR><A NAME="jmp"></A>
<CENTER>
<H2>
JMP</H2></CENTER>

<CENTER><FONT SIZE=+1>(JuMP)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Переход безусловный</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>jmp метка&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> используется в программе для организации безусловного
перехода как внутри текущего сегмента команд, так и за его пределы. При
определенных условиях в защищенном режиме работы команда jmp может использоваться
для переключения задач.

<P><I><A HREF="../Pic/P_2_49.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Команда jmp в зависимости от типа своего операнда изменяет содержимое
либо только одного регистра eip, либо обоих регистров cs и eip:
<UL>
<LI>
если операнд в команде jmp — метка в текущем сегменте команд (a8, 16, 32),
то ассемблер формирует машинную команду, операнд которой является значением
со знаком, являющимся смещением перехода относительно следующей за jmp
команды. При этом виде перехода изменяется только регистр eip/ip;</LI>

<LI>
если операнд в команде jmp — символический идентификатор ячейки памяти
(m16, 32, 48), то ассемблер предполагает, что в ней находится адрес, по
которому необходимо передать управление. Этот адрес может быть трех видов:</LI>

<UL>
<LI TYPE="SQUARE">
значением абсолютного смещения метки перехода относительно начала сегмента
кода. Размер этого смещения может быть 16 или 32 бит в зависимости от режима
адресации;</LI>

<LI TYPE="SQUARE">
дальним указателем на метку перехода в реальном и защищенном режимах, содержащим
два компонента адреса — сегментный и смещение. Размеры этих компонентов
также зависят от установленного режима адресации (use16 или use32). Если
текущим режимом является use16, то адрес сегмента и смещение занимают по
16 бит, причем смещение располагается в младшем слове двойного слова, отводимого
под этот полный адрес метки перехода. Если текущим режимом является use32,
то адрес сегмента и смещение занимают, соответственно, 16 и 32 бит, — в
младшем двойном слове находится смещение, в старшем — адрес сегмента;</LI>

<LI TYPE="SQUARE">
адресом в одном из 16 или 32-разрядных регистров — этот адрес представляет
собой абсолютное смещение метки, на которую необходимо передать управление,
относительно начала сегмента команд.</LI>
</UL>
</UL>
Для понимания различий механизмов перехода в реальном и защищенном режимах
нужно помнить следующее. В реальном режиме микропроцессор просто изменяет
cs и eip/ip в соответствии с содержимым указателя в памяти. В защищенном
режиме микропроцессор предварительно анализирует байт прав доступа AR в
дескрипторе, номер которого определяется по содержимому сегментной части
указателя. В зависимости от состояния байта AR микропроцессор выполняет
либо переход, либо переключение задач.
<BR><I>Состояние флагов после выполнения команды (за исключением случая
переключения задач):</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду jmp применяют для осуществления ближних и дальних безусловных
переходов без сохранения контекста точки перехода.
<BR><I>См. также:</I> урок 10, команды <A HREF="#call">call</A>, <A HREF="#jcc">jcc</A>
<BR><A NAME="lahf"></A>
<CENTER>
<H2>
LAHF</H2></CENTER>

<CENTER><FONT SIZE=+1>(Load AH register from register Flags)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Загрузка регистра AH флагами из регистра eFlags/Flags</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>lahf&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> извлечение содержимого младшего байта регистра eflags/flags,
в котором содержатся пять флагов: cf, pf, af, zf и sf.

<P><I><A HREF="../Pic/P_2_50.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>команда загружает регистр ah содержимым младшего байта регистра eflags/flags.
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Из-за того, что регистр флагов непосредственно недоступен, команду
lahf можно применять для анализа и последующего изменения командой sahf
состояния некоторых флагов регистра eflags/flags.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;сбросить в ноль флаг cf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lahf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; ah,11111110b
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sahf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> команду <A HREF="#sahf">sahf</A>
<BR><A NAME="lds"></A>
<CENTER>
<H2>
LDS/LES/LFS/LGS/LSS</H2></CENTER>

<CENTER><FONT SIZE=+1>(Load pointer into ds/es/fs/gs/ss segment register)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Загрузка сегментного регистра ds/es/fs/gs/ss указателем
из памяти</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>lds приемник,источник</FONT>&nbsp;
<BR><FONT SIZE=+0>les приемник,источник</FONT>&nbsp;
<BR><FONT SIZE=+0>lfs приемник,источник</FONT>&nbsp;
<BR><FONT SIZE=+0>lgs приемник,источник</FONT>&nbsp;
<BR><FONT SIZE=+0>lss приемник,источник</FONT>&nbsp;</TD>
</TR>
</TABLE>
<I>Назначение:</I> получение полного указателя в виде сегментной составляющей
и смещения.

<P><I><A HREF="../Pic/P_2_51.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Алгоритм работы команды зависит от действующего режима адресации (use16
или use32):
<UL>
<LI>
если use16, то загрузить первые два байта из ячейки памяти источник в 16-разрядный
регистр, указанный операндом приемник. Следующие два байта в области источник
должны содержать сегментную составляющую некоторого адреса; они загружаются
в регистр ds/es/fs/gs/ss;</LI>

<LI>
если use32, то загрузить первые четыре байта из ячейки памяти источник
в 32-разрядный регистр, указанный операндом приемник. Следующие два байта
в области источник должны содержать сегментную составляющую, или селектор,
некоторого адреса; они загружаются в регистр ds/es/fs/gs/ss.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Таким образом, с помощью данных команд в паре регистров ds/es/fs/gs/ss
и приемник оказывается полный адрес некоторой ячейки памяти. Это обстоятельство
можно использовать, к примеру, при работе с цепочечными командами, где
существуют жесткие соглашения на размещение адресов обрабатываемых строк.
Помните, что любая загрузка сегментного регистра приводит к обновлению
соответствующего теневого регистра (см. урок 16). Смотрите также описание
команды cmps с примером использования.
<BR><I>См. также:</I> уроки 5, 7, 11, команды <A HREF="#lea">lea</A> и
операторы ассемблера <A HREF="СтруктураПрограммы.htm#SEG">seg</A> и <A HREF="СтруктураПрограммы.htm#Offset">offset</A>
<BR><A NAME="lea"></A>
<CENTER>
<H2>
LEA</H2></CENTER>

<CENTER><FONT SIZE=+1>(Load Effective Address)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Загрузка эффективного адреса</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>lea приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> получение эффективного адреса (смещения) источника.

<P><I><A HREF="../Pic/P_2_52.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>алгоритм работы команды зависит от действующего режима адресации (use16
или use32):
<UL>
<LI>
если use16, то в регистр приемник загружается 16-битное значение смещения
операнда источник;</LI>

<LI>
если use32, то в регистр приемник загружается 32-битное значение смещения
операнда источник.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Данная команда является альтернативой оператору ассемблера offset.
В отличие от offset команда lea допускает индексацию операнда, что позволяет
более гибко организовать адресацию операндов.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;загрузить в регистр bx адрес пятого
элемента массива mas
.data
mas&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 dup (0)
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; di,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; bx,mas[di]
;или
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; bx,mas[4]
;или
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; bx,mas+4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 5, 7, 11 и команды <A HREF="#lea">lea</A>, <A HREF="#lds">lds</A>,
<A HREF="#lds">les</A>, <A HREF="#lds">lss</A>, <A HREF="#lds">lgs</A>,
<A HREF="#lds">lfs</A>, операторы ассемблера <A HREF="СтруктураПрограммы.htm#SEG">seg</A>
и <A HREF="СтруктураПрограммы.htm#Offset">offset</A>
<BR><A NAME="leave"></A>
<CENTER>
<H2>
LEAVE</H2></CENTER>

<CENTER><FONT SIZE=+1>(LEAVE from procedure)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Выход из процедуры</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>leave&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> удаление из стека области локальных (динамических) переменных,
выделенной командой enter.

<P><I><A HREF="../Pic/P_2_53.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>команда выполняет обратные команде enter действия:
<UL>
<LI>
содержимое ebp/bp копируется в esp/sp, тем самым восстанавливается значение
esp/sp, которое было до вызова данной процедуры. С другой стороны, восстановление
старого значения esp/sp означает освобождение пространства в стеке, отведенного
для завершающейся процедуры (локальные переменные процедуры уничтожаются);</LI>

<LI>
из стека восстанавливается содержимое ebp/bp, которое было до входа в процедуру.
После этого действия значение esp/sp также становится таким, каким оно
было до входа в процедуру.</LI>
</UL>
В результате этих двух действий также восстанавливается кадр стека, если
он был, вызывающей программы.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда leave не имеет операндов и выполняет обратные команде enter
действия. Эта команда должна находиться непосредственно перед командой
ret, которая в зависимости от соглашений конкретного языка по вызову процедур
удаляет или не удаляет аргументы из стека (см. урок 14).
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286
proc1&nbsp;&nbsp; proc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enter&nbsp;&nbsp; 16,0
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leave
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
proc1&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 14 и команды <A HREF="#enter">enter</A>, <A HREF="#ret">ret/retf</A>
<BR><A NAME="lgdt"></A>
<CENTER>
<H2>
LGDT</H2></CENTER>

<CENTER><FONT SIZE=+1>(Load Global Descriptor Table)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Загрузка регистра глобальной дескрипторной таблицы</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>lgdt источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> загрузка регистра gdtr значениями базового адреса и
размера глобальной дескрипторной таблицы GDT.

<P><I><A HREF="../Pic/P_2_54.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>команда выполняет загрузку 16 бит размера и 32 бит значения базового
адреса начала таблицы GDT в памяти в системный регистр gdtr. Эта загрузка
производится в соответствии с форматом этого регистра (см. урок 16). <I>Состояние
флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду lgdt применяют при подготовке к переходу в защищенный режим
для загрузки системного регистра gdtr. В качестве операнда в команде указывается
адрес области в формате 16+32. Младшее слово области — размер GDT, двойное
слово по старшему адресу — значение базового адреса начала этой таблицы.
Данные два компонента должны быть сформированы в памяти заранее.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286
;структура для описания псевдодескриптора gdtr
point&nbsp;&nbsp; STRUC
lim&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
adr&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;ENDS
.data
point_gdt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point&nbsp;&nbsp;&nbsp;<gdt_size,0>
.code
...
;загружаем gdtr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; eax,eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,gdt_seg
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp; eax,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; point_gdt.adr,eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lgdt&nbsp;&nbsp;&nbsp; point_gdt
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 16, 17 и команду <A HREF="#sgdt">sgdt</A>
<BR><A NAME="lidt"></A>
<CENTER>
<H2>
LIDT</H2></CENTER>

<CENTER><FONT SIZE=+1>(Load Interrupt Descriptor Table)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Загрузка регистра глобальной дескрипторной таблицы</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>lidt источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> загрузка регистра idtr значениями базового адреса и
размера глобальной дескрипторной таблицы IDT.

<P><I><A HREF="../Pic/P_2_55.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Команда lidt аналогична lgdt, но для дескрипторной таблицы прерываний
IDT (см. урок 17).
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду lidt применяют при подготовке к переходу в защищенный режим
для загрузки системного регистра idtr. В качестве операнда в команде указывается
адрес области в формате 16+32. Младшее слово области — размер IDT, двойное
слово по старшему адресу — значение базового адреса начала этой таблицы.
Два данных компонента должны быть сформированы в памяти заранее.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
;структура для описания псевдодескрипторов gdtr и idtr
point&nbsp;&nbsp; STRUC
lim&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
adr&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;ENDS
.data
point_idt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point&nbsp;&nbsp;&nbsp;<idt_size,0>
.code
...
;загружаем idtr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; eax,eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,IDT_SEG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp; eax,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; point_idt.adr,eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lidt&nbsp;&nbsp;&nbsp; point_idt
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 17 и команду <A HREF="#sidt">sidt</A>
<BR><A NAME="lods"></A>
<CENTER>
<H2>
LODS/LODSB/LODSW/LODSD</H2></CENTER>

<CENTER><FONT SIZE=+1>(LOad String Byte/Word/Double word operands)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Загрузка строки байтов/слов/двойных слов</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>lods источник</FONT>&nbsp;
<BR><FONT SIZE=+0>lodsb</FONT>&nbsp;
<BR><FONT SIZE=+0>lodsw</FONT>&nbsp;
<BR><FONT SIZE=+0>lodsd</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> загрузка элемента из последовательности (цепочки) в
регистр-аккумулятор al/ax/eax.

<P><I><A HREF="../Pic/P_2_56.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
загрузить элемент из ячейки памяти, адресуемой парой ds:esi/si, в регистр
al/ax/eax. Размер элемента определяется неявно (для команды lods) или явно
в соответствии с применяемой командой (для команд lodsb, lodsw, lodsd);</LI>

<LI>
изменить значение регистра si на величину, равную длине элемента цепочки.
Знак этой величины зависит от состояния флага df:</LI>

<UL>
<LI TYPE="SQUARE">
df=0 — значение положительное, то есть просмотр от начала цепочки к ее
концу;</LI>

<LI TYPE="SQUARE">
df=1 — значение отрицательное, то есть просмотр от конца цепочки к ее началу.</LI>
</UL>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команды извлекают элемент из ячейки памяти в один из регистров. Перед
командой lods можно указать префикс повторения rep, но в этом нет особого
смысла, так как обычно эту команду используют в некотором цикле для просмотра
некоторой цепочки с элементами фиксированного размера.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">str&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,str
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsb&nbsp;&nbsp; ;загрузить первый байт из str в al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 11 и команды <A HREF="#ins">ins/insb/insw/insd</A>,
<A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>, <A HREF="#movs">movs/movsb/movsw/movsd</A>,
<A HREF="#outs">outs</A>, <A HREF="#scas">scas/scasb/scasw/scasd</A>, <A HREF="#stos">stos/stosb/stosw/stosd</A>,
<A HREF="#rep">rep/repe/repz/repne/repnz</A>
<BR><A NAME="loop"></A>
<CENTER>
<H2>
LOOP</H2></CENTER>

<CENTER><FONT SIZE=+1>(LOOP control by register cx)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Управление циклом по cx</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>loop метка&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> организация цикла со счетчиком в регистре cx.

<P><I><A HREF="../Pic/P_2_57.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить декремент содержимого регистра <I>ecx/cx</I>;</LI>

<LI>
анализ регистра <I>ecx/cx</I>:</LI>

<UL>
<LI TYPE="SQUARE">
если <I>ecx/cx</I>=0, передать управление следующей за loop команде;</LI>

<LI TYPE="SQUARE">
если <I>ecx/cx</I>=1, передать управление команде, метка которой указана
в качестве операнда loop.</LI>
</UL>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду loop применяют для организации цикла со счетчиком. Количество
повторений цикла задается значением в регистре <I>ecx/cx</I> перед входом
в последовательность команд, составляющих тело цикла. Помните о двух важных
моментах:
<UL>
<LI>
для предотвращения выполнения цикла при нулевом <I>ecx/cx</I> используйте
команду jecxz/jcxz. Если этого не сделать, то при изначально нулевом <I>ecx/cx</I>
цикл повторится 4 294 967 295/65 536 раз;</LI>

<LI>
смещение метки, являющейся операндом loop, не должно выходить из диапазона
-128...+127 байт. Это смещение, как и в командах условного перехода, является
относительным от значения счетчика адреса следующей за loop команды.</LI>
</UL>
&nbsp;
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,10
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jcxz&nbsp;&nbsp;&nbsp; m1
cycl:
;тело цикла
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop&nbsp;&nbsp;&nbsp; cycl
m1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 10 и команды <A HREF="#jcc">jecxz</A>/<A HREF="#jcc">jcxz</A>,
<A HREF="#loope">loope</A>/<A HREF="#loope">loopz</A>, <A HREF="#loope">loopne</A>/<A HREF="#loope">loopnz</A>
<BR><A NAME="loope"></A>
<CENTER>
<H2>
LOOPE/LOOPZ<BR>
LOOPNE/LOOPNZ</H2></CENTER>

<CENTER><FONT SIZE=+1>(LOOP control by register cx not equal 0 and ZF=1)</FONT></CENTER>

<CENTER><FONT SIZE=+1>(LOOP control by register cx not equal 0 and ZF=0)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Управление циклом по cx c учетом значения флага ZF</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>loope/loopz метка</FONT>&nbsp;
<BR><FONT SIZE=+0>loopne/loopnz метка&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> организация цикла со счетчиком в регистре cx с учетом
флага zf.

<P><I><A HREF="../Pic/P_2_58.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить декремент содержимого регистра <I>ecx/cx</I>;</LI>

<LI>
проанализировать регистр <I>ecx/cx</I>:</LI>

<UL>
<LI TYPE="SQUARE">
если <I>ecx/cx</I>=0, передать управление следующей за loopxx команде;</LI>

<LI TYPE="SQUARE">
если <I>ecx/cx</I>=1, передать управление команде, метка которой указана
в качестве операнда loopxx;</LI>
</UL>

<LI>
анализ флага zf:</LI>

<UL>
<LI TYPE="SQUARE">
если zf=0, для команд loope/loopz это означает выход из цикла, для команд
loopne/loopnz — переход к началу цикла;</LI>

<LI TYPE="SQUARE">
если zf=1, для команд loope/loopz это означает переход к началу цикла,
для команд loopne/loopnz — выход из цикла.</LI>
</UL>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команды loopxx удобно использовать вместе с командами, которыe в результате
своей работы меняют значение флага zf. Типичный пример — команда сравнения
cmp.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;найти первый пробел в строке символов
str&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Найти первый пробел'
str_size=$-str
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,str_size
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,str
cycl:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; al,' '
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopne&nbsp; cycl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jcxz&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если пробелов нет
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp; si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;в si — адрес пробела в строке str
...
m1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 8, 10, 11 и команду <A HREF="#loop">loop</A>
<BR><A NAME="mov"></A>
<CENTER>
<H2>
MOV</H2></CENTER>

<CENTER><FONT SIZE=+1>(MOVe operand)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Пересылка операнда</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>mov приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> пересылка данных между регистрами или регистрами и памятью.

<P><I><A HREF="../Pic/P_2_59.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>копирование второго операнда в первый операнд.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда mov применяется для различного рода пересылок данных, при этом,
несмотря на всю простоту этого действия, необходимо помнить о некоторых
ограничениях и особенностях выполнения данной операции:
<UL>
<LI>
направление пересылки в команде mov всегда справа налево, то есть из второго
операнда в первый;</LI>

<LI>
значение второго операнда не изменяется;</LI>

<LI>
оба операнда не могут быть из памяти (при необходимости можно использовать
цепочечную команду movs);</LI>

<LI>
лишь один из операндов может быть сегментным регистром;</LI>

<LI>
желательно использовать в качестве одного из операндов регистр al/ax/eax,
так как в этом случае TASM генерирует более быструю форму команды mov.</LI>
</UL>
&nbsp;
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,5
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl,al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,ds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 10 и команды movs, <A HREF="#lods">lods/lodsb/lodsw/lodsd</A>,
<A HREF="#stos">stos/stosb</A>,
<BR><A HREF="#stos">stosw/stosd</A>
<CENTER>
<H2>
MOV</H2></CENTER>

<CENTER><FONT SIZE=+1>(MOVe operand to/from system registers)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Пересылка операнда в системные регистры (или из них)</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>mov приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> пересылка данных между регистрами или регистрами и памятью.

<P><I><A HREF="../Pic/P_2_60.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>копирование второго операнда в первый.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда mov применяется для обмена данными между системными регистрами.
Это одна из немногих возможностей доступа к содержимому этих регистров.
Данную команду можно использовать только на нулевом уровне привилегий либо
в реальном режиме работы микропроцессора.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286
;переключение микропроцессора в защищенный
режим36:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,cr0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bts&nbsp;&nbsp;&nbsp;&nbsp; eax,0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cr0,eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 16, 17 и команды <A HREF="#mov">mov</A>, <A HREF="#bts">bts</A>
<BR><A NAME="movs"></A>
<CENTER>
<H2>
MOVS/MOVSB/MOVSW/MOVSD</H2></CENTER>

<CENTER><FONT SIZE=+1>(MOVe String Byte/Word/Double word)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Пересылка строк байтов/слов/двойных слов</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>movs приемник,источник</FONT>&nbsp;
<BR><FONT SIZE=+0>movsb</FONT>&nbsp;
<BR><FONT SIZE=+0>movsw</FONT>&nbsp;
<BR><FONT SIZE=+0>movsd</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> пересылка элементов двух последовательностей (цепочек)
в памяти.

<P><I><A HREF="../Pic/P_2_61.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить копирование байта, слова или двойного слова из операнда источника
в операнд приемник, при этом адреса элементов предварительно должны быть
загружены:</LI>

<UL>
<LI TYPE="SQUARE">
адрес источника — в пару регистров ds:esi/si (<I>ds</I> по умолчанию, допускается
замена сегмента);</LI>

<LI TYPE="SQUARE">
адрес приемника — в пару регистров es:edi/di (замена сегмента не допускается);</LI>
</UL>

<LI>
в зависимости от состояния флага df изменить значение регистров esi/si
и edi/di:</LI>

<UL>
<LI TYPE="SQUARE">
если df=0, то увеличить содержимое этих регистров на длину структурного
элемента последовательности;</LI>

<LI TYPE="SQUARE">
если df=1, то уменьшить содержимое этих регистров на длину структурного
элемента последовательности;</LI>
</UL>

<LI>
если есть префикс повторения, то выполнить определяемые им действия (см.
команду rep).</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команды пересылают элемент из одной ячейки памяти в другую. Размеры
пересылаемых элементов зависят от применяемой команды. Команда movs может
работать с элементами размером в байт, слово, двойное слово. В качестве
операндов в команде указываются идентификаторы последовательностей этих
элементов в памяти. Реально эти идентификаторы используются лишь для получения
типов элементов последовательностей, а их адреса должны быть предварительно
загружены в указанные выше пары регистров. Транслятор, обработав команду
movs и выяснив тип операндов, генерирует одну из машинных команд movsb,
movsw или movsd. Машинного аналога для команды movs нет. Для адресации
операнда приемник обязательно должен использоваться регистр es.
<BR>Для того чтобы эти команды можно было использовать для пересылки последовательности
элементов, имеющих размерность байт, слово, двойное слово, необходимо использовать
префикс rep. Префикс rep заставляет циклически выполняться команды пересылки
до тех пор, пока содержимое регистра <I>ecx/cx</I> не станет равным нулю.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">str1&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'str1 копируется в str2'
len_str1=$-str1
a_str1&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str1
str2&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len_str1 dup (' ')
a_str2&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str2
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,len_str1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lds&nbsp;&nbsp;&nbsp;&nbsp; si,str1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; les&nbsp;&nbsp;&nbsp;&nbsp; di,str2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld
rep&nbsp;&nbsp;&nbsp;&nbsp; movsb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 11 и команды <A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>,
<A HREF="#ins">ins/insb/insw/insd</A>, <A HREF="#lods">lods/lodsb/lodsw/lodsd</A>,
<A HREF="#outs">outs</A>, <A HREF="#scas">scas/scasb/scasw/scasd</A>, <A HREF="#stos">stos/stosb/stosw/stosd</A>,
<A HREF="#rep">rep/repe/repz/repne/repnz</A>
<BR><A NAME="movsx"></A>
<CENTER>
<H2>
MOVSX</H2></CENTER>

<CENTER><FONT SIZE=+1>(MOVe and Sign eXtension)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Пересылка со знаковым расширением</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>movsx приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> преобразование элементов со знаком меньшей размерности
в эквивалентные им элементы со знаком большей размерности.

<P><I><A HREF="../Pic/P_2_62.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
считать содержимое источника;</LI>

<LI>
записать содержимое операнда источника в операнд приемник, начиная с младших
разрядов источника;</LI>

<LI>
распространить значение знакового разряда источника на свободные старшие
разряды операнда назначения.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду movsx обычно используют для получения эквивалентного, но большего
по размеру операнда со знаком. Это может понадобиться для приведения размера
операнда к нужному значению с целью обеспечения работы следующих команд
программы:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,0ffh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movsx&nbsp;&nbsp; bx,al&nbsp;&nbsp; ;bx=0ffffh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 8 и команды <I><A HREF="#mov">mov</A></I>, <I><A HREF="#movs">movs</A></I>,
<I><A HREF="#movzx">movzx</A></I>, <I><A HREF="#cbw">cbw</A></I>, <I><A HREF="#cwd">cwd</A></I>,
<I><A HREF="#cdq">cdq</A></I>
<BR><A NAME="movzx"></A>
<CENTER>
<H2>
MOVZX</H2></CENTER>

<CENTER><FONT SIZE=+1>(MOVe and Zero eXtension)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Пересылка с нулевым расширением</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>movzx приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> преобразование элементов без знака меньшей размерности
в эквивалентные им элементы без знака большей размерности.

<P><I><A HREF="../Pic/P_2_63.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
считать содержимое источника;</LI>

<LI>
записать содержимое операнда источника в операнд приемник, начиная с его
младших разрядов;</LI>

<LI>
распространить двоичный нуль на свободные старшие разряды операнда назначения.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду movzx обычно используют для получения эквивалентного, но большего
по размеру операнда без учета знака. Она может быть использована для согласования
операндов различной размерности. Но не следует думать, что все эти разнотипные
пересылки делает одна машинная команда. На самом деле существует несколько
машинных команд, каждая из которых работает со своими размерами операндов.
Генерацию же нужной команды обеспечивает транслятор на основе анализа исходного
текста программы.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.data
sl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,0ffh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; bx,al&nbsp;&nbsp; ;bx=00ffh
...
;или из памяти:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; eax,byte ptr sl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 8 и команды <A HREF="#mov">mov</A>, <A HREF="#movs">movs/movsb/</A>
<BR><A HREF="#movs">movsw/movsd</A>, <A HREF="#movsx">movsx</A>, <A HREF="#cbw">cbw</A>,
<A HREF="#cwd">cwd</A>, <A HREF="#cdq">cdq</A>
<BR><A NAME="mul"></A>
<CENTER>
<H2>
MUL</H2></CENTER>

<CENTER><FONT SIZE=+1>(MULtiply)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Умножение целочисленное без учета знака</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>mul множитель_1&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> операция умножения двух целых чисел без учета знака.

<P><I><A HREF="../Pic/P_2_64.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Команда выполняет умножение двух операндов без учета знаков. Алгоритм
зависит от формата операнда команды и требует явного указания местоположения
только одного сомножителя, который может быть расположен в памяти или в
регистре. Местоположение второго сомножителя фиксировано и зависит от размера
первого сомножителя:
<UL>
<LI>
если операнд, указанный в команде — байт, то второй сомножитель должен
располагаться в al;</LI>

<LI>
если операнд, указанный в команде — слово, то второй сомножитель должен
располагаться в ax;</LI>

<LI>
если операнд, указанный в команде — двойное слово, то второй сомножитель
должен располагаться в eax.</LI>
</UL>
Результат умножения помещается также в фиксированное место, определяемое
размером сомножителей:
<UL>
<LI>
при умножении байтов результат помещается в ax;</LI>

<LI>
при умножении слов результат помещается в пару dx:ax;</LI>

<LI>
при умножении двойных слов результат помещается в пару edx:eax.</LI>
</UL>
<I>Состояние флагов после выполнения команды (если старшая половина результата
нулевая):</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>0</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?&nbsp;</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<I>Состояние флагов после выполнения команды (если старшая половина результата
ненулевая):</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>1</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?</TD>

<TD>?&nbsp;</TD>

<TD>1</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда mul выполняет целочисленное умножение операндов без учета их
знаковых разрядов. Для этой операции необходимо наличие двух операндов-сомножителей,
размещение одного из которых фиксировано, а другого задается операндом
в команде. Контролировать размер результата удобно используя флаги cf и
of.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">mn_1&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15
mn_2&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,mn_1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul&nbsp;&nbsp;&nbsp;&nbsp; mn_2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 8 и команду <I><A HREF="#imul">imul</A></I>
<BR><A NAME="neg"></A>
<CENTER>
<H2>
NEG</H2></CENTER>

<CENTER><FONT SIZE=+1>(NEGate operand)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Изменить знак операнда</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>neg источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> изменение знака (получение двоичного дополнения) источника.

<P><I><A HREF="../Pic/P_2_65.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить вычитание (0 – источник) и поместить результат на место источника;</LI>

<LI>
если источник=0, то его значение не меняется.</LI>
</UL>
<I>Состояние флагов после выполнения команды (если результат нулевой):</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<I>Состояние флагов после выполнения команды (если результат ненулевой):</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>1</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда используется для формирования двоичного дополнения операнда
в памяти или регистре. Операция двоичного дополнения предполагает инвертирование
всех разрядов операнда с последующим сложением операнда с двоичной единицей.
Если операнд отрицательный, то операция neg над ним означает получение
его модуля.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; neg&nbsp;&nbsp;&nbsp;&nbsp; al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;al=0feh — число -2 в дополнительном коде
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 6, 8 и команду <A HREF="#not">not</A>
<BR><A NAME="nop"></A>
<CENTER>
<H2>
NOP</H2></CENTER>

<CENTER><FONT SIZE=+1>(No OPeration)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Нет операции</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>nop&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> пустая команда.

<P><I><A HREF="../Pic/P_2_66.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>не производит никаких действий.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда nop, занимая один байт, может использоваться для резервирования
места в сегменте кода или организации программной задержки. В качестве
иллюстрации можно обратиться к примеру, приведенному в описании команды
hlt. В этом примере команду nop можно использовать вместо jmp $+2. Назначение
jmp $+2 в этом фрагменте — задержка для синхронизации работы микропроцессора
и аппаратуры компьютера.
<BR><A NAME="not"></A>
<CENTER>
<H2>
NOT</H2></CENTER>

<CENTER><FONT SIZE=+1>(NOT operand)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Инвертирование операнда</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>not источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> инвертирование всех битов операнда источник.

<P><I><A HREF="../Pic/P_2_67.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>инвертировать все биты операнда источника: из 1 в 0, из 0 в 1.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду not можно использовать для изменения байта, выполняющего роль
некоторого флага, с целью отслеживания некоторых логических условий в программе.
Но такой способ не оптимален, эту ситуацию мы обсуждали в книге на уроках
9 и 12.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">flag&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ffh ;значение флага — истина
...
cycl:
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; flag,0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1
...
m1:&nbsp;&nbsp;&nbsp;&nbsp; not&nbsp;&nbsp;&nbsp;&nbsp; flag&nbsp;&nbsp;&nbsp; ;установить флаг в истину
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 9, 12 и команду <A HREF="#neg">neg</A>
<BR><A NAME="or"></A>
<CENTER>
<H2>
OR</H2></CENTER>

<CENTER><FONT SIZE=+1>(logical OR)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Логическое включающее ИЛИ</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>or приемник,маска&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> операция логического ИЛИ над битами операнда назначения.

<P><I><A HREF="../Pic/P_2_68.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить операцию логического ИЛИ над битами операнда назначения, используя
в качестве маски второй операнд — маска. При этом бит результата равен
0, если соответствующие биты операндов маска и назначения равны 0, в противном
случае бит равен 1;</LI>

<LI>
записать результат операции в источник (операнд маска остается неизменным);</LI>

<LI>
установить флаги.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>0</TD>

<TD>r</TD>

<TD>r</TD>

<TD>?</TD>

<TD>r&nbsp;</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду or можно использовать для работы с операндами на уровне битов.
Типичное использование команды — установка определенных разрядов первого
операнда в единицу.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bl,al&nbsp;&nbsp; ;установить нулевой бит в 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#and">and</A>, <A HREF="#xor">xor</A>,
<A HREF="#not">not</A>
<BR><A NAME="out"></A>
<CENTER>
<H2>
OUT</H2></CENTER>

<CENTER><FONT SIZE=+1>(OUT operand to port)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Вывод операнда в порт</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>out ном_порта,аккумулятор&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> вывод значения в порт ввода-вывода.

<P><I><A HREF="../Pic/P_2_69.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Передать байт, слово, двойное слово из регистра al/ax/eax в порт, номер
которого определяется первым операндом.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда применяется для прямого управления оборудованием компьютера
посредством портов. Номер порта задается первым операндом в виде непосредственного
значения или значения в регистре dx. Непосредственным значением можно задать
порт с номером в диапазоне 0...255. Для указания порта с большим номером
используется регистр dx. Размер данных определяется размерностью второго
операнда и может быть байтом, словом или двойным словом.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; 64h,al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 2, 7, 16, 17 и команды <A HREF="#in">in</A>, <A HREF="#ins">ins/insb/insw/insd</A>,
<A HREF="#outs">outs</A>
<BR><A NAME="outs"></A>
<CENTER>
<H2>
OUTS/OUTSB/OUTSW/OUTSD</H2></CENTER>

<CENTER><FONT SIZE=+1>(OUTput Byte/Word/Double word String to port)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Вывод строки байтов/слов/двойных слов в порт</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>outs порт,источник</FONT>&nbsp;
<BR><FONT SIZE=+0>outsb</FONT>&nbsp;
<BR><FONT SIZE=+0>outsw</FONT>&nbsp;
<BR><FONT SIZE=+0>outsd</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> вывод в порт из памяти последовательности байт, слов,
двойных слов.

<P><I><A HREF="../Pic/P_2_70.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
передать данные в порт ввода-вывода, номер которого загружен в регистр
dx, из ячейки памяти по адресу ds:esi/si;</LI>

<LI>
в зависимости от состояния флага df изменить значение регистров esi/si:</LI>

<UL>
<LI TYPE="SQUARE">
если df=0, то увеличить содержимое этих регистров на длину структурного
элемента последовательности;</LI>

<LI TYPE="SQUARE">
если df=1, то уменьшить содержимое этих регистров на длину структурного
элемента последовательности;</LI>
</UL>

<LI>
при наличии префикса выполнить определяемые им deiqrbh (см. команду <A HREF="#rep">rep/repe/repz/repne/repnz</A>).</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда выводит данные в порт ввода-вывода, номер которого загружен
в регистр dx, из ячейки памяти по адресу ds:esi/si (допускается замена
сегмента). Недопустимо задание номера порта в команде в виде непосредственного
операнда — для этого используется регистр dx. Размеры вводимых элементов
зависят от применяемой команды. Команда outs может работать с элементами
размером в байт, слово или двойное слово. В качестве операнда в команде
указывается символическое имя ячейки памяти, из которой элемент выводится
в порт ввода-вывода. Реально символическое имя используется лишь для получения
типа элемента последовательности, а ее адрес должен быть предварительно
загружен в пару регистров ds:esi/si. Транслятор, обработав команду outs
и выяснив тип операндов, генерирует одну из машинных команд outsb, outsw
или outsd. Машинного аналога для команды outs нет.
<BR>Для того чтобы эти команды можно было использовать для вывода в порт
последовательности элементов, имеющих размерность байт, слово или двойное
слово, необходимо использовать префикс rep. Он заставляет циклически выполняться
команду вывода в порт до тех пор, пока содержимое регистра <I>ecx/cx</I>
не станет равным нулю.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286
;вывести последовательность 10 байт в порт 300h
;(номер порта взят условно)
str_10&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 dup(0)
adr_str dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str_10
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lds&nbsp;&nbsp;&nbsp;&nbsp; si,adr_str
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,300h
rep&nbsp;&nbsp;&nbsp;&nbsp; outsb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 2, 7, 11 и команды <A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>,
<A HREF="#lods">lods/lodsb/lodsw/lodsd</A>, <A HREF="#movs">movs/movsb/movsw/movsd,</A>
<A HREF="#ins">ins/insb/insw/insd</A>, <A HREF="#scas">scas/scasb/scasw/scasd</A>,
<A HREF="#stos">stos/stosb/stosw/stosd</A>, <A HREF="#rep">rep/repe/repz/repne/repnz</A>
<BR><A NAME="pop"></A>
<CENTER>
<H2>
POP</H2></CENTER>

<CENTER><FONT SIZE=+1>(POP operand from the stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Извлечение операнда из стека</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>pop приемник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> извлечение слова или двойного слова из стека.

<P><I><A HREF="../Pic/P_2_71.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Алгоритм работы команды зависит от установленного атрибута размера
адреса — use16 или use32:
<UL>
<LI>
загрузить в приемник содержимое вершины стека (адресуется парой ss:esp/sp);</LI>

<LI>
увеличить содержимое esp/sp на 4 (2 байта) для use32 (соответственно для
use16).</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда применяется для восстановления содержимого вершины стека в
регистр, ячейку памяти или сегментный регистр. Заметим, что недопустимо
восстановление значения в сегментный регистр cs.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">my_proc proc&nbsp;&nbsp;&nbsp; near
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bx
;тело процедуры, в которой изменяется содержимое
;регистров ax и bx
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#popa">popa</A>,
<A HREF="#popad">popad</A>, <A HREF="#popf">popf</A>, <A HREF="#popfd">popfd</A>,
<A HREF="#push">push</A>, <A HREF="#pusha">pusha</A>, <A HREF="#pushad">pushad</A>,
<A HREF="#pushf">pushf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="popa"></A>
<CENTER>
<H2>
POPA</H2></CENTER>

<CENTER><FONT SIZE=+1>(POP All general registers from the stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Извлечение всех регистров общего назначения из стека</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>popa&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> извлечение из стека регистров общего назначения di,
si, bp, sp, bx, dx, cx, ax.

<P><I><A HREF="../Pic/P_2_72.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
извлечь из стека последовательно значения и загрузить ими регистры общего
назначения di, si, bp, sp, bx, dx, cx, ax. Содержимое di восстанавливается
первым. Содержимое sp извлекается, но не восстанавливается;</LI>

<LI>
увеличить значение указателя стека esp/sp на 16.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда popa по принципу работы является обратной команде pusha и используется
для восстановления содержимого всех регистров общего назначения значениями
из стека. Эту команду можно использовать в процедурах и программах обработки
прерываний для восстановления регистров общего назначения прерванной программы.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
my_proc proc&nbsp;&nbsp;&nbsp; near
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pusha
;тело процедуры, в которой изменяется
;содержимое регистров общего назначения
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popa
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popad">popad</A>, <A HREF="#popf">popf</A>, <A HREF="#popfd">popfd</A>,
<A HREF="#push">push</A>, <A HREF="#pusha">pusha</A>, <A HREF="#pushad">pushad</A>,
<A HREF="#pushf">pushf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="popad"></A>
<CENTER>
<H2>
POPAD</H2></CENTER>

<CENTER><FONT SIZE=+1>(POP All general Double word registers from the stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Извлечение всех 32-разрядных регистров общего назначения
из стека</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>popad&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> извлечение из стека регистров общего назначения edi,
esi, ebp, esp, ebx, edx, ecx, eax.

<P><I><A HREF="../Pic/P_2_73.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
извлечь из стека последовательно значения и загрузить ими 32-разрядные
регистры общего назначения edi, esi, ebp, esp, ebx, edx, ecx, eax. Содержимое
edi восстанавливается первым. Содержимое esp извлекается но не восстанавливается;</LI>

<LI>
увеличить значение указателя стека esp на 32.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда popad по принципу работы является обратной команде pushad и
используется для восстановления всех 32-разрядных регистров общего назначения.
Эту команду можно использовать в процедурах и программах обработки прерываний
для восстановления регистров общего назначения прерванной программы.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
my_proc proc&nbsp;&nbsp;&nbsp; near
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushad
;тело процедуры, в которой изменяется
;содержимое регистров общего назначения
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popad
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popa">popa</A>, <A HREF="#popf">popf</A>, <A HREF="#popfd">popfd</A>,
<A HREF="#push">push</A>, <A HREF="#pusha">pusha</A>, <A HREF="#pushad">pushad</A>,
<A HREF="#pushf">pushf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="popf"></A>
<CENTER>
<H2>
POPF</H2></CENTER>

<CENTER><FONT SIZE=+1>(POP Flags register from the stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Извлечение регистра флагов из стека</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>popf&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> извлечение из стека слова и восстановление его в регистр
флагов flags.

<P><I><A HREF="../Pic/P_2_74.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
извлечь из вершины стека слово и поместить его в регистр flags;</LI>

<LI>
увеличить значение указателя стека esp на 2.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>14</TD>

<TD>1312</TD>

<TD>11</TD>

<TD>10</TD>

<TD>09</TD>

<TD>08</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>NT</TD>

<TD>IOPL</TD>

<TD>OF</TD>

<TD>DF</TD>

<TD>IF</TD>

<TD>TF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда popf по принципу работы является обратной команде pushf и используется
для восстановления из стека содержимого регистра флагов eflags. Возможным
вариантом использования этой команды являются программы обработки прерываний
или другие случаи, в которых необходимо сохранять некоторый локальный контекст
процесса вычисления. Из-за того, что регистр eflags/flags непосредственно
недоступен, команда popf является одной из немногих возможностей влияния
на его содержимое.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;установить значение регистра flags в 03h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,3h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popa">popa</A>, <A HREF="#popad">popad</A>, <A HREF="#popfd">popfd</A>,
<A HREF="#push">push</A>, <A HREF="#pusha">pusha</A>, <A HREF="#pushad">pushad</A>,
<A HREF="#pushf">pushf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="popfd"></A>
<CENTER>
<H2>
POPFD</H2></CENTER>

<CENTER><FONT SIZE=+1>(POP eFlags Double word register from the stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Извлечение расширенного регистра флагов из стека</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>popfd&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> извлечение из стека двойного слова и восстановление
его в регистр флагов eflags.

<P><I><A HREF="../Pic/P_2_75.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
извлечь из вершины стека двойное слово и поместить его в регистр eflags;</LI>

<LI>
увеличить значение указателя стека esp на 4.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>17</TD>

<TD>16</TD>

<TD>14</TD>

<TD>1312</TD>

<TD>11</TD>

<TD>10</TD>

<TD>09</TD>

<TD>08</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>VM</TD>

<TD>RF</TD>

<TD>NT</TD>

<TD>IOPL</TD>

<TD>OF</TD>

<TD>DF</TD>

<TD>IF</TD>

<TD>TF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>0</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда popfd по принципу работы является обратной командой команде
pushfd и используется для восстановления из стека содержимого регистра
флагов eflags. Необходимо отметить, что команда popfd не влияет на состояние
флагов vm и rf.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
;установить значение регистра eflags в 03h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,3h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popfd&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp; ;установить новое значение eflags
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popa">popa</A>, <A HREF="#popad">popad</A>, <A HREF="#popf">popf</A>,
<A HREF="#push">push</A>, <A HREF="#pusha">pusha</A>, <A HREF="#pushad">pushad</A>,
<A HREF="#pushf">pushf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="push"></A>
<CENTER>
<H2>
PUSH</H2></CENTER>

<CENTER><FONT SIZE=+1>(PUSH operand onto stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Размещение операнда в стеке</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>push источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> размещение содержимого операнда источник в стеке.

<P><I><A HREF="../Pic/P_2_76.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
уменьшить значение указателя стека esp/sp на 4/2 (в зависимости от значения
атрибута размера адреса — use16 или use32);</LI>

<LI>
записать источник в вершину стека (адресуемую парой ss:esp/sp).</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда push используется совместно с командой pop для записи значений
в стек и извлечения их из стека. Размер записываемых значений — слово или
двойное слово. Также в стек можно записывать непосредственные значения.
Заметьте, что в отличие от команды pop в стек можно включать значение сегментного
регистра cs. Другой интересный момент связан с регистром sp. Команда push
esp/sp записывает в стек значение esp/sp по состоянию до выдачи этой команды.
В микропроцессоре i8086 по этой команде записывалось скорректированное
значение sp. При записи в стек 8-битных значений для них все равно выделяется
слово или двойное слово (в зависимости от use16 или use32).
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">my_proc proc&nbsp;&nbsp;&nbsp; near
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bx
;тело процедуры, в которой изменяется содержимое
;регистров ax и bx
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popa">popa</A>, <A HREF="#popad">popad</A>, <A HREF="#popf">popf</A>,
<A HREF="#popfd">popfd</A>, <A HREF="#pusha">pusha</A>, <A HREF="#pushad">pushad</A>,
<A HREF="#pushf">pushf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="pusha"></A>
<CENTER>
<H2>
PUSHA</H2></CENTER>

<CENTER><FONT SIZE=+1>(PUSH All general registers onto stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Размещение всех регистров общего назначения в стеке</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>pusha&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> размещение в стеке регистров общего назначения в следующей
последовательности: ax, cx, dx, bx, sp, bp, si, di.

<P><I><A HREF="../Pic/P_2_77.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
уменьшить значение указателя стека esp/sp на 32/16 (в зависимости от значения
атрибута размера адреса — use16 или use32);</LI>

<LI>
включить в стек последовательно значения регистров общего назначения ax,
cx, dx, bx, sp, bp, si, di.</LI>
</UL>
Содержимое di при этом будет на вершине стека. В стек помещается содержимое
sp по состоянию до выполнения команды.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда pusha используется совместно с командой popa для сохранения
и восстановления всех регистров общего назначения. Эти команды удобно использовать
при работе с процедурами, программами обработки прерываний, а также в других
случаях для сохранения и восстановления регистров общего назначения как
части контекста некоторого вычислительного процесса.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">my_proc proc&nbsp;&nbsp;&nbsp; near
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pusha
;тело процедуры, в которой изменяется
;содержимое регистров общего назначения
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popa
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popad">popad</A>, <A HREF="#popf">popf</A>, <A HREF="#popfd">popfd</A>,
<A HREF="#push">push</A>, <A HREF="#popa">popa</A>, <A HREF="#pushad">pushad</A>,
<A HREF="#pushf">pushf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="pushad"></A>
<CENTER>
<H2>
PUSHAD</H2></CENTER>

<CENTER><FONT SIZE=+1>(PUSH All general Double word registers onto stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Размещение всех регистров общего назначения в стеке</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>pushad&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> размещение в стеке регистров общего назначения в следующей
последовательности: eax, ecx, edx, ebx, esp, ebp, esi, edi.

<P><I><A HREF="../Pic/P_2_78.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
уменьшить значение указателя стека esp на 32;</LI>

<LI>
включить в стек последовательно значения регистров общего назначения eax,
ecx, edx, ebx, esp, ebp, esi, edi. Содержимое edi при этом будет на вершине
стека. Содержимое esp включается по состоянию на момент, предшествовавший
выполнению данной команды.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда pushad используется совместно с командой popad для сохранения
и восстановления всех регистров общего назначения. Эти команды используются
аналогично командам popa и pusha.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
my_proc proc&nbsp;&nbsp;&nbsp; near
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushad
;тело процедуры, в которой изменяется
;содержимое регистров общего назначения
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popad
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popa">popa</A>, <A HREF="#popf">popf</A>, <A HREF="#popfd">popfd</A>,
<A HREF="#push">push</A>, <A HREF="#pusha">pusha</A>, <A HREF="#popad">popad</A>,
<A HREF="#pushf">pushf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="pushf"></A>
<CENTER>
<H2>
PUSHF</H2></CENTER>

<CENTER><FONT SIZE=+1>(PUSH Flags register onto stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Размещение регистра флагов в стеке</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>pushf&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> размещение в вершине стека (ss:sp) содержимого регистра
флагов flags.

<P><I><A HREF="../Pic/P_2_79.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
уменьшить значение указателя стека sp на 2;</LI>

<LI>
поместить в вершину стека содержимое регистра flags.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда pushf может использоваться для получения содержимого регистра
флагов. Как известно, прямой доступ к регистру флагов невозможен, поэтому
данная команда является одной из немногих команд, позволяющих получить
доступ к регистру флагов как к содержимому обычного регистра. Обратное
действие, то есть восстановление — возможно измененного слова — в регистр
флагов, осуществляется командой popf. Эта команда может использоваться
в программах обработки прерываний и в других случаях, когда необходимо
сохранить локальный контекст процесса вычисления.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;извлечь значение регистра flags и изменить
;значение флага cf на обратное
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; ax,01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popa">popa</A>, <A HREF="#popad">popad</A>, <A HREF="#popfd">popfd</A>,
<A HREF="#push">push</A>, <A HREF="#pusha">pusha</A>, <A HREF="#pushad">pushad</A>,
<A HREF="#popf">popf</A>, <A HREF="#pushfd">pushfd</A>
<BR><A NAME="pushfd"></A>
<CENTER>
<H2>
PUSHFD</H2></CENTER>

<CENTER><FONT SIZE=+1>(PUSH eFlags Double word register onto stack)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Размещение расширенного регистра флагов в стеке</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>pushfd&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> размещение в стеке содержимого регистра флагов eflags.

<P><I><A HREF="../Pic/P_2_80.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
уменьшить значение указателя стека esp на 4;</LI>

<LI>
записать в вершину стека двойное слово, представляющее собой содержимое
регистра eflags.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команды pushfd и popfd используются аналогично командам pushf и popf.
Команда pushfd применяется для получения содержимого регистра флагов. Как
известно, прямой доступ к регистру флагов невозможен, поэтому данная команда
является одной из немногих команд, позволяющих получить доступ к регистру
флагов как к содержимому обычного регистра. Обратное действие, то есть
восстановление — возможно измененного слова — в регистр флагов, осуществляется
командой popfd. Эта команда может использоваться в программах обработки
прерываний или в других случаях, когда необходимо сохранить локальный контекст
процесса вычисления.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
;извлечь значение регистра eflags и изменить
;значение флага cf на обратное
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushfd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; eax,01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popfd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 10, 14, 15, 16, 17 и команды <A HREF="#pop">pop</A>,
<A HREF="#popa">popa</A>, <A HREF="#popad">popad</A>, <A HREF="#popf">popf</A>,
<A HREF="#popfd">popfd</A>, <A HREF="#push">push</A>, <A HREF="#pusha">pusha</A>,
<A HREF="#pushad">pushad</A>, <A HREF="#pushf">pushf</A>
<BR><A NAME="rcl"></A>
<CENTER>
<H2>
RCL</H2></CENTER>

<CENTER><FONT SIZE=+1>(Rotate operand through Carry flag Left)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Циклический сдвиг операнда влево через флаг переноса</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>rcl операнд,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> операция циклического сдвига операнда влево через флаг
переноса cf.

<P><I><A HREF="../Pic/P_2_81.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвиг всех битов операнда влево на один разряд, при этом старший бит операнда
становится значением флага переноса cf;</LI>

<LI>
одновременно старое значение флага переноса cf вдвигается в операнд справа
и становится значением младшего бита операнда;</LI>

<LI>
указанные выше два действия повторяются количество раз, равное значению
второго операнда команды rcl.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
Здесь обозначение ?r означает то, что анализ состояния флага имеет смысл
при определенном сочетании операндов. В случае команды rcl флаг of представляет
интерес, если сдвиг осуществляется на один разряд (см. ниже описание применения
команды rcl).
<BR><I>Применение:</I>
<BR>Команда rcl используется для циклического сдвига разрядов операнда
влево. Особенность этого сдвига в том, что он происходит с некоторой задержкой,
так как очередной сдвигаемый бит оказывается на некоторое время вне операнда.
В это время можно произвести его извлечение и (или) подмену. Другой важный
момент заключается в том, что для счетчика сдвига микропроцессор использует
только пять младших разрядов операнда количество_разрядов. Таким образом,
значение, большее 31, микропроцессором не допускается (аппаратно это ограничение
реализуется тем, что игнорируются значения всех битов счетчика, кроме первых
пяти). Обратите внимание на еще один интересный эффект, связанный с поведением
флага of. В операциях сдвига на один разряд по изменению этого флага можно
судить о факте изменения знакового (старшего) разряда операнда:
<UL>
<LI>
of=1, если текущее значение флага cf и выдвигаемого бита операнда слева
различны;</LI>

<LI>
of=0, если текущее значение флага cf и выдвигаемого бита операнда слева
совпадают.</LI>
</UL>
&nbsp;
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;сдвиг операнда, занимающего два двойных слова
;на четыре разряда влево
ch_l&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp; ;младшая часть 64-битного операнда
ch-2&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp; ;старшая часть 64-битного операнда
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,4&nbsp;&nbsp;&nbsp; ;счетчик сдвигов в cx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,ch_l
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,ch_h
m1:&nbsp;&nbsp;&nbsp;&nbsp; clc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;очистка флага cf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcl&nbsp;&nbsp;&nbsp;&nbsp; eax,1&nbsp;&nbsp; ;старший бит eax в cf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcl&nbsp;&nbsp;&nbsp;&nbsp; edx,1&nbsp;&nbsp; ;cf в младший бит edx, старший бит edx в cf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop&nbsp;&nbsp;&nbsp; m1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#rcr">rcr</A>, <A HREF="#rol">rol</A>,
<A HREF="#ror">ror</A>, <A HREF="#sal">sal</A>, <A HREF="#sar">sar</A>,
<A HREF="#shl">shl</A>, <A HREF="#shr">shr</A>
<BR><A NAME="rcr"></A>
<CENTER>
<H2>
RCR</H2></CENTER>

<CENTER><FONT SIZE=+1>(Rotate operand through Carry flag Right)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Циклический сдвиг операнда вправо через флаг переноса</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>rcr операнд,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> операция циклического сдвига операнда вправо через флаг
переноса cf.

<P><I><A HREF="../Pic/P_2_82.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвиг всех битов операнда вправо на один разряд; при этом младший бит операнда
становится значением флага переноса cf;</LI>

<LI>
одновременно старое значение флага переноса — в операнд слева и становится
значением старшего бита операнда;</LI>

<LI>
указанные выше два действия повторяются количество раз, равное значению
второго операнда команды rcr.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
Здесь обозначение ?r означает то, что анализ состояния флага имеет смысл
при определенном сочетании операндов. В случае команды rcr флаг of представляет
интерес, если сдвиг осуществляется на один разряд (см. ниже описание применения
команды rcr).
<BR><I>Применение:</I>
<BR>Команда rcr используется для циклического сдвига разрядов операнда
вправо. Особенность этого сдвига в том, что он происходит с некоторой задержкой,
так как очередной сдвигаемый бит оказывается на некоторое время вне операнда.
В это время можно произвести его извлечение и (или) подмену. Другой важный
момент заключается в том, что для счетчика сдвига микропроцессор использует
только пять младших разрядов операнда количество_разрядов. Таким образом,
значение, большее 31, не допускается (аппаратно это ограничение реализуется
тем, что игнорируются значения битов счетчика старше пятого). Обратите
внимание на еще один интересный эффект, связанный с поведением флага of,
— его значение имеет смысл только в операциях сдвига на один разряд и обусловлено
тем, что по изменению этого флага можно судить о факте изменения знакового
разряда операнда:
<UL>
<LI>
of=1, если текущие (то есть до операции сдвига) значения флага cf и старшего,
левого бита операнда различны;</LI>

<LI>
of=0, если текущие (то есть до операции сдвига) значения флага cf и старшего,
левого бита операнда слева совпадают.</LI>
</UL>
&nbsp;
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;подсчет числа единичных битов в операнде
operand dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,16&nbsp;&nbsp; ;размер операнда
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; al,al&nbsp;&nbsp; ;счетчик единичных битов
cycl:&nbsp;&nbsp; rcr&nbsp;&nbsp;&nbsp;&nbsp; operand,1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $+4&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если очередной выдвинутый бит равен 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; $+4&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если очередной выдвинутый бит равен 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;увеличить счетчик единичных битов
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop&nbsp;&nbsp;&nbsp; cycl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#rcl">rcl</A>, <A HREF="#rol">rol</A>,
<A HREF="#ror">ror</A>, <A HREF="#sal">sal</A>, <A HREF="#sar">sar</A>,
<A HREF="#shl">shl</A>, <A HREF="#shr">shr</A>
<BR><A NAME="rep"></A>
<CENTER>
<H2>
REP/REPE/REPZ/REPNE/REPNZ</H2></CENTER>

<CENTER><FONT SIZE=+1>(REPeat string operation)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Повторить цепочечную операцию</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>rep</FONT>&nbsp;
<BR><FONT SIZE=+0>repe</FONT>&nbsp;
<BR><FONT SIZE=+0>repz</FONT>&nbsp;
<BR><FONT SIZE=+0>repne</FONT>&nbsp;
<BR><FONT SIZE=+0>repnz</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> указание условного и безусловного повторения следующей
за данной командой цепочечной операции.

<P><I><A HREF="../Pic/P_2_83.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Алгоритм работы зависит от конкретного префикса. Префиксы rep, repe
и repz на самом деле имеют одинаковый код операции, их действия зависят
от той цепочечной команды, которую они предваряют:
<UL>
<LI>
rep используется перед следующими цепочечными командами и их краткими эквивалентами:
movs, stos, ins, outs. Действия rep:</LI>

<OL>
<LI>
анализ содержимого cx:</LI>

<UL>
<LI>
если cx&lt;>0, то выполнить цепочечную команду, следующую за данным префиксом
и перейти к шагу 2;</LI>

<LI>
если cx=0, то передать управление команде, следующей за данной цепочечной
командой (выйти из цикла по rep);</LI>
</UL>

<LI>
уменьшить значение cx=cx–1 и вернуться к шагу 1;</LI>
</OL>

<LI>
repe и repz используются перед следующими цепочечными командами и их краткими
эквивалентами: cmps, scas. Действия repe и repz:</LI>

<OL>
<LI>
анализ содержимого cx и флага zf:</LI>

<UL>
<LI>
если cx&lt;>0 или zf&lt;>0, то выполнить цепочечную команду, следующую
за данным префиксом, и перейти к шагу 2;</LI>

<LI>
если cx=0 или zf=0, то передать управление команде, следующей за данной
цепочечной командой (выйти из цикла по rep);</LI>
</UL>

<LI>
уменьшить значение cx=cx-1 и вернуться к шагу 1;</LI>
</OL>

<LI>
repne и repnz также имеют один код операции и имеют смысл при использовании
перед следующими цепочечными командами и их краткими эквивалентами: cmps,
scas. Действия repne и repnz:</LI>

<OL>
<LI>
анализ содержимого cx и флага zf:</LI>

<UL>
<LI>
если cx&lt;>0 или zf=0, то выполнить цепочечную команду, следующую за данным
префиксом и перейти к шагу 2;</LI>

<LI>
если cx=0 или zf&lt;>0, то передать управление команде, следующей за данной
цепочечной командой (выйти из цикла по rep);</LI>
</UL>

<LI>
уменьшить значение cx=cx–1 и вернуться к шагу 1.</LI>
</OL>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>06</TD>
</TR>

<TR>
<TD>ZF</TD>
</TR>

<TR>
<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команды rep, repe, repz, repne и repnz в силу специфики своей работы
называются префиксами. Они имеют смысл только при использовании цепочечных
операций, заставляя их циклически выполняться и тем самым без организации
внешнего цикла обрабатывать последовательности элементов фиксированной
длины. Большинство применяемых префиксов являются условными, то есть они
прекращают работу цепочечной команды при выполнении определенных условий.
<BR><I>См. также:</I> урок 11 и команды <A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>,
<A HREF="#ins">ins/insb/insw/insd</A>, <A HREF="#outs">outs</A>, <A HREF="#movs">movs/movsb/movsw/movsd,</A>
<A HREF="#scas">scas/scasb/scasw/scasd</A>, <A HREF="#stos">stos/stosb</A>
<BR><A HREF="#stos">/stosw/stosd</A>
<BR><A NAME="ret"></A>
<CENTER>
<H2>
RET/RETF</H2></CENTER>

<CENTER><FONT SIZE=+1>(RETurn/RETurn Far from procedure)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Возврат ближний (дальний) из процедуры</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>ret</FONT>&nbsp;
<BR><FONT SIZE=+0>ret число</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> возврат управления из процедуры вызывающей программе.

<P><I><A HREF="../Pic/P_2_84.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Работа команды зависит от типа процедуры:
<UL>
<LI>
для процедур ближнего типа — восстановить из стека содержимое eip/ip;</LI>

<LI>
для процедур дальнего типа — последовательно восстановить из стека содержимое
eip/ip и сегментного регистра cs.</LI>

<LI>
если команда ret имеет операнд, то увеличить содержимое esp/sp на величину
операнда число; при этом учитывается атрибут режима адресации — use16 или
use32:</LI>

<UL>
<LI TYPE="SQUARE">
если use16, то sp=(sp+число), то есть указатель стека сдвигается на число
байт, равное значению число;</LI>

<LI TYPE="SQUARE">
если use32, то sp=(sp+2*число), то есть указатель стека сдвигается на число
слов, равное значению число.</LI>
</UL>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду ret необходимо применять для возврата управления вызывающей
программе из процедуры, управление которой было передано по команде call.
На самом деле микропроцессор имеет три варианта команды возврата ret -
это ret, ее синоним retn, а также команда retf. Они отличаются типами процедур,
в которых используются. Команды ret и retn служат для возврата из процедур
ближнего типа. Команда retf — команда возврата для процедур дальнего типа.
Какая конкретно команда будет использоваться, определяется компилятором;
программисту лучше использовать команду ret и доверить транслятору самому
сгенерировать ее ближний или дальний вариант. Количество команд ret в процедуре
должно соответствовать количеству точек выхода из нее.
<BR>Некоторые языки высокого уровня, к примеру Pascal, требуют, чтобы вызываемая
процедура очищала стек от переданных ей параметров. Для этого команда ret
содержит необязательный параметр число, который, в зависимости от установленного
атрибута размера адреса, означает количество байт или слов, удаляемых из
стека по окончании работы процедуры.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">my_proc proc
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp; 6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 10, 14 и команду <I><A HREF="#call">call</A></I>
<BR><A NAME="rol"></A>
<CENTER>
<H2>
ROL</H2></CENTER>

<CENTER><FONT SIZE=+1>(Rotate operand Left)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Циклический сдвиг операнда влево</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>rol операнд,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> операция циклического сдвига операнда влево.

<P><I><A HREF="../Pic/P_2_85.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвиг всех битов операнда влево на один разряд, при этом старший бит операнда
вдвигается в операнд справа и становится значением младшего бита операнда;</LI>

<LI>
одновременно выдвигаемый бит становится значением флага переноса cf;</LI>

<LI>
указанные выше два действия повторяются количество раз, равное значению
второго операнда.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда rol используется для циклического сдвига разрядов операнда
влево. Отличие этого сдвига от rcl в том, что очередной сдвигаемый бит
одновременно вдвигается в операнд справа и становится значением флага cf.
Так же, как и для других сдвигов, значение второго операнда (счетчика сдвига)
ограничено диапазоном 0...31. Это объясняется тем, что микропроцессор использует
только пять младших разрядов операнда количество_разрядов. Аналогично другим
командам сдвига сохраняется эффект, связанный с поведением флага of, значение
которого имеет смысл только в операциях сдвига на один разряд:
<UL>
<LI>
если of=1, то текущее значение флага cf и выдвигаемого слева бита операнда
различны;</LI>

<LI>
если of=0, то текущее значение флага cf и выдвигаемого слева бита операнда
совпадают.</LI>
</UL>
Этот эффект, как вы помните, обусловлен тем, что флаг of устанавливается
в единицу всякий раз при изменении знакового разряда операнда.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;поменять местами половинки регистра eax:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,0ffff0000h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cl,16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rol&nbsp;&nbsp;&nbsp;&nbsp; eax,cl&nbsp; ;eax=0000ffffh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#rcr">rcr</A>, <A HREF="#rcl">rcl</A>,
<A HREF="#ror">ror</A>, <A HREF="#sal">sal</A>, <A HREF="#sar">sar</A>,
<A HREF="#shl">shl</A>, <A HREF="#shr">shr</A>
<BR><A NAME="ror"></A>
<CENTER>
<H2>
ROR</H2></CENTER>

<CENTER><FONT SIZE=+1>Циклический сдвиг операнда вправо</FONT></CENTER>

<CENTER><FONT SIZE=+1>ASCII-коррекция после сложения</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>ror операнд,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> операция циклического сдвига операнда вправо.

<P><I><A HREF="../Pic/P_2_86.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвиг всех битов операнда вправо на один разряд, при этом младший бит операнда
вдвигается в операнд слева и становится значением старшего бита операнда;</LI>

<LI>
одновременно этот младший бит операнда становится значением флага переноса
cf;</LI>

<LI>
старое значение флага переноса cf вдвигается в операнд слева и становится
значением старшего бита операнда;</LI>

<LI>
указанные выше два действия повторяются количество раз, равное значению
второго операнда.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда ror используется для циклического сдвига разрядов операнда
вправо. Отличие этого сдвига от rcr в том, что очередной сдвигаемый бит
одновременно вдвигается в операнд слева и становится значением флага cf.
Так же, как и для других сдвигов, значение второго операнда (счетчика сдвига)
ограничено диапазоном 0...31. Это объясняется тем, что микропроцессор использует
только пять младших разрядов операнда количество_разрядов. Аналогично другим
командам сдвига сохраняется эффект, связанный с поведением флага of, значение
которого имеет смысл только в операциях сдвига на один разряд:
<UL>
<LI>
если of=1, то текущее значение флага cf и вдвигаемого слева бита операнда
различны;</LI>

<LI>
если of=0, то текущее значение флага cf и вдвигаемого слева бита операнда
совпадают;</LI>
</UL>
Этот эффект, как вы помните, обусловлен тем, что флаг of устанавливается
в единицу всякий раз при изменении знакового разряда операнда.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;поместить четыре младших бита ax на место старших битов:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ror&nbsp;&nbsp;&nbsp;&nbsp; ax,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 9 и команды <A HREF="#rcl">rcl</A>, <A HREF="#rcl">rcr</A>,
<A HREF="#ror">ror</A>, <A HREF="#sal">sal</A>, <A HREF="#sar">sar</A>,
<A HREF="#shl">shl</A>, <A HREF="#shr">shr</A>
<BR><A NAME="sahf"></A>
<CENTER>
<H2>
SAHF</H2></CENTER>

<CENTER><FONT SIZE=+1>(Store AH register into register Flags)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Загрузка регистра флагов eFlags/Flags из регистра
AH</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>sahf&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> запись содержимого регистра ah в младший байт регистра
eflags/flags, в котором содержатся пять флагов cf, pf, af, zf и sf.

<P><I><A HREF="../Pic/P_2_87.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Команда загружает младший байт регистра eflags/flags содержимым регистра
ah. В битах 7, 6, 4, 2 и 0 регистра ah должны, соответственно, содержаться
новые значения флагов sf, zf, af, pf и cf.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Эта команда используется совместно с командой lahf. Из-за того, что
регистр флагов непосредственно недоступен, сочетание этих команд можно
применять для анализа — и, возможно, изменения — состояния некоторых флагов
в регистре eflags/flags. Содержимое старшей части регистра флагов не изменяется.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;сбросить в ноль флаг cf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lahf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; ah,11111110b
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sahf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 2, 7 и команду <A HREF="#lahf">lahf</A>
<BR><A NAME="sal"></A>
<CENTER>
<H2>
SAL</H2></CENTER>

<CENTER><FONT SIZE=+1>(Shift Arithmetic operand Left)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сдвиг арифметический операнда влево</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>sal операнд,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> арифметический сдвиг операнда влево.

<P><I><A HREF="../Pic/P_2_88.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвиг всех битов операнда влево на один разряд, при этом выдвигаемый слева
бит становится значением флага переноса cf;</LI>

<LI>
одновременно справа в операнд вдвигается нулевой бит;</LI>

<LI>
указанные выше два действия повторяются количество раз, равное значению
второго операнда.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда sal используется для сдвига разрядов операнда влево. Так же,
как и для других сдвигов, значение второго операнда (счетчика сдвига) ограничено
диапазоном 0...31. Это объясняется тем, что микропроцессор использует только
пять младших разрядов количество_разрядов. Аналогично другим командам сдвига
сохраняется эффект, связанный с поведением флага of, значение которого
имеет смысл только в операциях сдвига на один разряд:
<UL>
<LI>
если of=1, то текущее значение флага cf и выдвигаемого слева бита операнда
различны;</LI>

<LI>
если of=0, то текущее значение флага cf и выдвигаемого слева бита операнда
совпадают.</LI>
</UL>
Этот эффект, как вы помните, обусловлен тем, что флаг cf устанавливается
в единицу всякий раз при изменении знакового разряда операнда.
<BR>Команду sal удобно использовать для умножения целочисленных операндов
без знака на степени 2. Кстати сказать, это самый быстрый способ такого
умножения; умножить содержимое ax на 16 (2 в степени 4):
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,17
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sal&nbsp;&nbsp;&nbsp;&nbsp; ax,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 8, 9 и команды <A HREF="#rcr">rcr</A>, <A HREF="#rcl">rcl</A>,
<A HREF="#ror">ror</A>, <A HREF="#rol">rol</A>, <A HREF="#sar">sar</A>,
<A HREF="#shl">shl</A>, <A HREF="#shr">shr</A>
<BR><A NAME="sar"></A>
<CENTER>
<H2>
SAR</H2></CENTER>

<CENTER><FONT SIZE=+1>(Shift Arithmetic operand Right)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сдвиг арифметический операнда вправо</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>sar операнд,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> арифметический сдвиг операнда вправо.

<P><I><A HREF="../Pic/P_2_89.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвиг всех битов операнда вправо на один разряд, при этом выдвигаемый справа
бит становится значением флага переноса cf;</LI>

<LI>
обратите внимание: одновременно слева в операнд вдвигается не нулевой бит,
а значение старшего бита операнда, то есть по мере сдвига вправо освобождающиеся
места заполняются значением знакового разряда. По этой причине этот тип
сдвига и называется арифметическим;</LI>

<LI>
указанные выше два действия повторяются количество раз, равное значению
второго операнда.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда sar используется для арифметического сдвига разрядов операнда
вправо. Так же, как и для других сдвигов, значение второго операнда (счетчика
сдвига) ограничено диапазоном 0...31. Это объясняется тем, что микропроцессор
использует только пять младших разрядов операнда количество_разрядов. В
отличие от других команд сдвига флаг of всегда сбрасывается в ноль в операциях
сдвига на один разряд.
<BR>Команду sar можно использовать для деления целочисленных операндов
со знаком на степени 2.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,88
;(ax) разделить на 2 во второй степени, то есть на 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sar&nbsp;&nbsp;&nbsp;&nbsp; ax,2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 8, 9 и команды <A HREF="#rcr">rcr</A>, <A HREF="#rcl">rcl</A>,
<A HREF="#ror">ror</A>, <A HREF="#rol">rol</A>, <A HREF="#sal">sal</A>,
<A HREF="#shl">shl</A>, <A HREF="#shr">shr</A>
<BR><A NAME="sbb"></A>
<CENTER>
<H2>
SBB</H2></CENTER>

<CENTER><FONT SIZE=+1>(SuBtract with Borrow)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Вычитание с заемом</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>sbb операнд_1,операнд_2&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> целочисленное вычитание с учетом результата предыдущего
вычитания командами sbb и sub (по состоянию флага переноса cf).

<P><I><A HREF="../Pic/P_2_90.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить сложение операнд_2=операнд_2+(cf);</LI>

<LI>
выполнить вычитание операнд_1=операнд_1-операнд_2;</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда sbb используется для выполнения вычитания старших частей значений
многобайтных операндов с учетом возможного предыдущего заема при вычитании
младших частей значений этих операндов.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;выполнить вычитание 64-битных значений: vich_1-vich_2
vich_1&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 dup (0)
vich_2&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 dup (0)
rez&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 dup (0)
...
;ввести значения в поля vich_1 и vich_2:
;младший байт по младшему адресу
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,vich_1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; eax,vich_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;вычесть младшие половинки чисел
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; rez,eax ;младшая часть результата
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,vich_1+4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sbb&nbsp;&nbsp;&nbsp;&nbsp; eax,vich_2+4&nbsp;&nbsp;&nbsp; ;вычесть старшие половинки чисел
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; rez+4,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;старшая часть результата
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 8, Приложение 7 и команды <A HREF="#sub">sub</A>
<BR><A NAME="scas"></A>
<CENTER>
<H2>
SCAS/SCASB/SCASW/SCASD</H2></CENTER>

<CENTER><FONT SIZE=+1>Сканирование строки байтов/слов/двойных слов</FONT></CENTER>

<CENTER><FONT SIZE=+1>ASCII-коррекция после сложения</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>scas приемник</FONT>&nbsp;
<BR><FONT SIZE=+0>scasb</FONT>&nbsp;
<BR><FONT SIZE=+0>scasw</FONT>&nbsp;
<BR><FONT SIZE=+0>scasd</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> поиск значения в последовательности (цепочке) элементов
в памяти.

<P><I><A HREF="../Pic/P_2_91.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить вычитание (элемент цепочки-(eax/ax/al)). Элемент цепочки локализуется
парой es:edi/di. Замена сегмента es не допускается;</LI>

<LI>
по результату вычитания установить флаги;</LI>

<LI>
изменить значение регистра edi/di на величину, равную длине элемента цепочки.
Знак этой величины зависит от состояния флага df:</LI>

<UL>
<LI TYPE="SQUARE">
df=0 — величина положительная, то есть просмотр от начала цепочки к ее
концу;</LI>

<LI TYPE="SQUARE">
df=1 — величина отрицательная, то есть просмотр от конца цепочки к ее началу.</LI>
</UL>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команды сканирования сравнивают значение в регистре eax/ax/al с ячейкой
памяти, локализуемой парой регистров es:edi/di. Размер сравниваемого элемента
зависит от применяемой команды. Команда scas может работать с элементами
размером в байт, слово или двойное слово. В качестве операнда в команде
указывается идентификатор последовательности элементов в памяти. Реально
этот идентификатор используется лишь для получения типа элементов последовательности,
а ее адрес должен быть предварительно загружен в указанную выше пару регистров.
Транслятор, обработав команду scas и выяснив тип операндов, генерирует
одну из машинных команд:: scasb, scasw или scasd. Машинного аналога для
команды scas нет. Для адресации операнда источник обязательно должен использоваться
регистр es.
<BR>Для того чтобы эту команду можно было использовать для поиска значения
в последовательности элементов, имеющих размерность байт, слово или двойное
слово, необходимо использовать один из префиксов repe или repne. Эти префиксы
не только заставляют циклически выполняться команду поиска, пока <I>ecx/cx</I>&lt;>0,
но и отслеживают состояние флага zf (см. команды rep/repe/repne).
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;сосчитать число пробелов в строке str
.data
str&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '...'
len_str=$-str
.code
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,str
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,len_str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;длину строки — в cx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,' '
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,0&nbsp;&nbsp;&nbsp; ;счетчик для подсчета пробелов в строке
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld
cycl:
repe&nbsp;&nbsp;&nbsp; scasb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jcxz&nbsp;&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp; ;переход на exit, если цепочка просмотрена полностью
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; cycl
exit:&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 11 и команды <A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>,
<A HREF="#ins">ins/insb/insw/insd</A>, <A HREF="#lods">lods/lodsb/lodsw/lodsd</A>,
<A HREF="#movs">movs/movsb/movsw/movsd,</A> <A HREF="#outs">outs</A>, <A HREF="#stos">stos/stosb</A>
<BR><A HREF="#stos">/stosw/stosd</A>, <A HREF="#rep">rep/repe/repz/repne/repnz</A>
<BR><A NAME="setcc"></A>
<CENTER>
<H2>
SETcc</H2></CENTER>

<CENTER><FONT SIZE=+1>(byte SET on condition)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Установка байта по условию</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>setcc операнд&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> установка операнда логическим значением в зависимости
от истинности условия, заданного модификатором кода операции cc.

<P><I><A HREF="../Pic/P_2_92.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Команда проверяет истинность условия, заданного в коде операции, то
есть, фактически, состояние определенных флагов.

<P><I>Команды установки байтов</I>
<TABLE BORDER=2 COLS=3 BGCOLOR="#CFFFFF" >
<TR ALIGN=CENTER>
<TD>Команда</TD>

<TD>Проверяемые флаги</TD>

<TD>Логическое условие</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETA/SETNBE</TD>

<TD>CF = 0 и ZF = 0</TD>

<TD>(выше)/(не ниже или равно)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETAE/SETNB</TD>

<TD>CF = 0</TD>

<TD>(выше или равно)/(не ниже)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETB/SETNAE&nbsp;</TD>

<TD>CF = 1</TD>

<TD>(ниже)/(не выше или равно)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETBE/SETNA</TD>

<TD>CF = 1 или ZF = 1</TD>

<TD>(ниже или равно)/(не выше)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETC</TD>

<TD>CF = 1</TD>

<TD>перенос</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETE/SETZ</TD>

<TD>ZF = 1</TD>

<TD>ноль</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETG/SETNLE</TD>

<TD>ZF = 0 или SF = OF</TD>

<TD>(больше)/(не меньше или равно)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETGE/SETNL</TD>

<TD>SF = OF</TD>

<TD>(больше или равно)/(не меньше)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETL/SETNGE</TD>

<TD>SF &lt;> OF</TD>

<TD>если SF &lt;> OF</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETLE/SETNG</TD>

<TD>ZF=1 или SF &lt;> OF</TD>

<TD>(меньше или равно)/(не больше)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETNC</TD>

<TD>CF = 0</TD>

<TD>нет переноса</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETNE/SETNZ</TD>

<TD>ZF = 0</TD>

<TD>не равно нулю</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETNO</TD>

<TD>OF=0</TD>

<TD>нет переполнения</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETNP/SETPO</TD>

<TD>PF = 0</TD>

<TD>(неравенство)/(нет контроля четности)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETNS</TD>

<TD>SF = 0</TD>

<TD>нет знака, число положительное</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETO</TD>

<TD>OF = 1</TD>

<TD>переполнение</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETP/SETPE</TD>

<TD>PF = 1</TD>

<TD>контроль четности/равенство</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SETS</TD>

<TD>SF = 1</TD>

<TD>если знак минус, число отрицательное</TD>
</TR>
</TABLE>
Если проверяемое условие (или содержимое соответствующих флагов на момент
выдачи команды setcc) истинно, то установить значение операнда в 01h, если
условие ложно — то в 00h.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Эти команды можно использовать после любой команды, изменяющей флаги,
при необходимости анализа результата изменений. Если проанализировать условия
для команд условного перехода, то обнаружится их полное соответствие с
условиями, обрабатываемыми командой setcc, за исключением, конечно, команд
jcxz и jecxz.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;подсчитать число единичных битов в регистре ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,16
m1:&nbsp;&nbsp;&nbsp;&nbsp; rol&nbsp;&nbsp;&nbsp;&nbsp; ax,1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setc&nbsp;&nbsp;&nbsp; bl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; bh,bl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop&nbsp;&nbsp;&nbsp; m1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 10 и команду jcc
<BR><A NAME="sgdt"></A>
<CENTER>
<H2>
SGDT</H2></CENTER>

<CENTER><FONT SIZE=+1>(Store Global Descriptor Table)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сохранение регистра глобальной дескрипторной таблицы</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>sgdt источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> извлечение содержимого системного регистра gdtr, содержащего
значения базового адреса и размера глобальной дескрипторной таблицы GDT.

<P><I><A HREF="../Pic/P_2_93.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>Команда выполняет чтение содержимого системного регистра gdtr в область
памяти размером 48 бит. Структурно эти 48 бит представляют 16 бит размера
и 32 бита значения базового адреса начала таблицы GDT в памяти.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду sgdt применяют при работе системных программ с уровнем привилегий
0, в частности, при написании различных драйверов.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286
;структура для описания псевдодескриптора gdtr
point&nbsp;&nbsp; STRUC
lim&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
adr&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDS
.data
point_gdt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point&nbsp;&nbsp;&nbsp;<gdt_size,0>
.code
...
;читаем содержимое gdtr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sgdt&nbsp;&nbsp;&nbsp; point_gdt
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 16, 17 и команду <A HREF="#lgdt">lgdt</A>
<BR><A NAME="sidt"></A>
<CENTER>
<H2>
SIDT</H2></CENTER>

<CENTER><FONT SIZE=+1>(Store Interrupt Descriptor Table)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сохранение регистра глобальной дескрипторной таблицы
прерываний</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>sidt источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> извлечение содержимого системного регистра idtr, содержащего
значения базового адреса и размера дескрипторной таблицы прерываний IDT.

<P><I><A HREF="../Pic/P_2_94.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>команда sidt выполняет чтение содержимого системного регистра idtr
в область памяти размером 48 бит. Структурно эти 48 бит представляют 16
бит размера и 32 бита значения базового адреса начала таблицы IDT в памяти.
<BR><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду sidt применяют при работе системных программ с уровнем привилегий
0, в частности, при написании различных драйверов. В качестве операнда
в команде указывается адрес области в формате 16+32. Младшее слово области
— размер IDT, двойное слово по старшему адресу — значение базового адреса
начала этой таблицы.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.286
;структура для описания псевдодескрипторов gdtr и idtr
point&nbsp;&nbsp; STRUC
lim&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
adr&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDS
.data
point_idt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point&nbsp;&nbsp;&nbsp;<idt_size,0>
.code
...
;читаем содержимое idtr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sidt&nbsp;&nbsp;&nbsp; point_idt
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 17 и команду <A HREF="#lidt">lidt</A>
<BR><A NAME="shl"></A>
<CENTER>
<H2>
SHL</H2></CENTER>

<CENTER><FONT SIZE=+1>(SHift logical Left)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сдвиг логический операнда влево</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>shl операнд,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> логический сдвиг операнда влево.

<P><I><A HREF="../Pic/P_2_95.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвиг всех битов операнда влево на один разряд, при этом выдвигаемый слева
бит становится значением флага переноса cf;</LI>

<LI>
одновременно слева в операнд вдвигается нулевой бит;</LI>

<LI>
указанные выше два действия повторяются количество раз, равное значению
второго операнда.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?r</TD>

<TD>r&nbsp;</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда shl используется для сдвига разрядов операнда влево. Ее машинный
код идентичен коду sal, поэтому вся информация, приведенная для sal, относится
и к команде shl. Команда shl используется для сдвига разрядов операнда
влево. Так же, как и для других сдвигов, значение второго операнда (счетчикк
сдвига) ограничено диапазоном 0...31. Это объясняется тем, что микропроцессор
использует только пять младших разрядов операнда количество_разрядов. Аналогично
другим командам сдвига сохраняется эффект, связанный с поведением флага
of, значение которого имеет смысл только в операциях сдвига на один разряд:
<UL>
<LI>
если of=1, то текущее значение флага cf и выдвигаемого слева бита операнда
различны;</LI>

<LI>
если of=0, то текущее значение флага cf и выдвигаемого слева бита операнда
совпадают.</LI>
</UL>
Этот эффект, как вы помните, обусловлен тем, что флаг of устанавливается
в единицу всякий раз при изменении знакового разряда операнда.
<BR>Команду shl удобно использовать для умножения целочисленных операндов
без знака на степени 2. Кстати сказать, это самый быстрый способ умножения;&nbsp;
умножить содержимое ax на 16 (2 в степени 4).
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,17
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp; ax,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#rcr">rcr</A>, <A HREF="#rcl">rcl</A>,
<A HREF="#ror">ror</A>, <A HREF="#rol">rol</A>, <A HREF="#sar">sar</A>,
<A HREF="#sal">sal</A>, <A HREF="#shr">shr</A>
<BR><A NAME="shld"></A>
<CENTER>
<H2>
SHLD</H2></CENTER>

<CENTER><FONT SIZE=+1>(SHift Left Double word)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сдвиг двойного слова влево</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>shld приемник,источник,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> логический сдвиг двойного слова влево.

<P><I><A HREF="../Pic/P_2_96.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвинуть операнд приемник влево на количество битов, определяемое операндом
количество_сдвигов;</LI>

<LI>
одновременно сдвинуть операнд источник влево на количество битов, определяемое
операндом количество_сдвигов. Важно заметить, что операнд источник только
обеспечивает вдвигаемые в операнд приемник биты, сам он при этом не изменяется;</LI>

<LI>
выдвигаемые во время сдвига влево из операнда источник биты вдвигаются
в операнд приемник с его правого края.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>r</TD>

<TD>r</TD>

<TD>?</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда shld используется для манипуляции битовыми строками длиной
до 64 бит. Эту команду удобно использовать для быстрой вставки (или извлечения)
битной строки в большую битную строку; при этом, что очень важно, не разрушается
контекст (битное окружение) этих подстрок.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
;извлечь старшую половину eax в bx без разрушения eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cl,16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shld&nbsp;&nbsp;&nbsp; ebx,eax,cl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp; ebx,cl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shld&nbsp;&nbsp;&nbsp; eax,ebx,cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;восстановим eax pop bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#rcr">rcr</A>, <A HREF="#rcl">rcl</A>,
<A HREF="#ror">ror</A>, <A HREF="#rol">rol</A>, <A HREF="#sar">sar</A>,
<A HREF="#sal">sal</A>, <A HREF="#shr">shr</A>, <A HREF="#shrd">shrd</A>
<BR><A NAME="shr"></A>
<CENTER>
<H2>
SHR</H2></CENTER>

<CENTER><FONT SIZE=+1>Сдвиг логический операнда вправо</FONT></CENTER>

<CENTER><FONT SIZE=+1>ASCII-коррекция после сложения</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>shr операнд,кол-во_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> логический сдвиг операнда вправо.

<P><I><A HREF="../Pic/P_2_97.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвиг всех битов операнда вправо на один разряд; при этом выдвигаемый справа
бит становится значением флага переноса cf;</LI>

<LI>
одновременно слева в операнд вдвигается нулевой бит;</LI>

<LI>
указанные выше два действия повторяются количество раз, равное значению
второго операнда.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>?</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда shr используется для логического сдвига разрядов операнда вправо.
Так же, как и для других сдвигов, значение второго операнда (счетчика сдвига)
ограничено диапазоном 0...31. Это объясняется тем, что микропроцессор использует
только пять младших разрядов операнда количество_разрядов. В отличие от
других команд сдвига, флаг of всегда сбрасывается в ноль в операциях сдвига
на один разряд.
<BR>Команду shr можно использовать для деления целочисленных операндов
без знака на степени 2.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cl,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shr&nbsp;&nbsp;&nbsp;&nbsp; eax,cl&nbsp; ;(eax) разделить на 2 в степени 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#rcr">rcr</A>, <A HREF="#rcl">rcl</A>,
<A HREF="#ror">ror</A>, <A HREF="#rol">rol</A>, <A HREF="#sal">sal</A>,
<A HREF="#shl">shl</A>, <A HREF="#sar">sar</A>
<BR><A NAME="shrd"></A>
<CENTER>
<H2>
SHRD</H2></CENTER>

<CENTER><FONT SIZE=+1>(SHift Right Double word)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сдвиг двойного слова вправо</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>shrd приемник,источник,количество_сдвигов&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> логический сдвиг двойного слова вправо.

<P><I><A HREF="../Pic/P_2_98.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
сдвинуть операнд приемник вправо на количество битов, определяемое операндом
количество_сдвигов;</LI>

<LI>
одновременно сдвинуть операнд источник вправо на количество битов, определяемое
операндом количество_сдвигов. Важно заметить, что операнд источник только
обеспечивает вдвигаемые в операнд приемник биты, сам он при этом не изменяется;</LI>

<LI>
выдвигаемые вправо во время сдвига из операнда источник биты вдвигаются
в операнд приемник с его левого конца.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>?</TD>

<TD>r</TD>

<TD>r</TD>

<TD>?</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда shrd используется для манипуляции битными строками длиной до
64 бит. Эту команду удобно использовать для быстрой вставки (или извлечения)
битной строки в большую битную строку, при этом, что очень важно, не разрушается
контекст (битное окружение) этих подстрок.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.386
;разделить операнд размером 64 бит на степень 2
op_l&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp; ;младшая часть операнда
op_h&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp; ;старшая часть операнда
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,op_h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shrd&nbsp;&nbsp;&nbsp; op_l,eax,4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;разделить операнд на 4
;так как старшая часть операнда реально еще не сдвинулась,
;то нужно привести ее в соответствие с результатом
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shr&nbsp;&nbsp;&nbsp;&nbsp; op_h,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#rcr">rcr</A>, <A HREF="#rcl">rcl</A>,
<A HREF="#ror">ror</A>, <A HREF="#rol">rol</A>, <A HREF="#sar">sar</A>,
<A HREF="#sal">sal</A>, <A HREF="#shr">shr</A>, <A HREF="#shld">shld</A>
<BR><A NAME="stc"></A>
<CENTER>
<H2>
STC</H2></CENTER>

<CENTER><FONT SIZE=+1>(Set Carry Flag)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Установка флага переноса</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>stc&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> установка флага переноса cf в 1.

<P><I><A HREF="../Pic/P_2_99.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>установить флаг cf в единицу.

<P><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>00</TD>
</TR>

<TR>
<TD>CF</TD>
</TR>

<TR>
<TD>1</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Данная команда используется для установки флага cf в единицу. Такая
необходимость может возникнуть при работе с командами сдвига, арифметическими
командами или действиями по индикации ошибок в программах.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;cf=1
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 2, 8, 9 и команды <A HREF="#cmc">cmc</A>, <A HREF="#clc">clc</A>
<BR><A NAME="std"></A>
<CENTER>
<H2>
STD</H2></CENTER>

<CENTER><FONT SIZE=+1>(SeT Direction Flag)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Установка флага направления</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>std&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> установка флага направления df в 1.

<P><I><A HREF="../Pic/P_2_100.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>установить флаг df в единицу.

<P><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>10</TD>
</TR>

<TR>
<TD>DF</TD>
</TR>

<TR>
<TD>1</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Данная команда используется для установки флага df в единицу. Такая
необходимость может возникнуть при работе с цепочечными командами. Единичное
состояние флага df вынуждает микропроцессор производить декремент регистров
si и di при выполнении цепочечных операций.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;df=1
;смотрите материал урока 11
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 2, 11 и команду <A HREF="#cld">cld</A>
<BR><A NAME="sti"></A>
<CENTER>
<H2>
STI</H2></CENTER>

<CENTER><FONT SIZE=+1>(SeT Interrupt flag)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Установка флага прерывания</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>sti&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> установка флага прерывания if в единицу.

<P><I><A HREF="../Pic/P_2_101.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>установить флаг if в единицу.

<P><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>09</TD>
</TR>

<TR>
<TD>IF</TD>
</TR>

<TR>
<TD>1</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Данная команда используется для установки флага if в единицу. Такая
необходимость может возникнуть при разработке программ обработки прерываний.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sti&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;if=1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 2, 15, 17 и команду <A HREF="#cli">cli</A>
<BR><A NAME="stos"></A>
<CENTER>
<H2>
STOS/STOSB/STOSW/STOSD</H2></CENTER>

<CENTER><FONT SIZE=+1>(Store String Byte/Word/Double word operands)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Сохранение строки байтов/слов/двойных слов</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>stos приемник</FONT>&nbsp;
<BR><FONT SIZE=+0>stosb</FONT>&nbsp;
<BR><FONT SIZE=+0>stosw</FONT>&nbsp;
<BR><FONT SIZE=+0>stosd</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> сохранение элемента из регистра-аккумулятора al/ax/eax
в последовательности (цепочке).

<P><I><A HREF="../Pic/P_2_102.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
записать элемент из регистра al/ax/eax в ячейку памяти, адресуемую парой
es:di/edi. Размер элемента определяется неявно (для команды stos) или конкретной
применяемой командой (для команд stosb, stosw, stosd);</LI>

<LI>
изменить значение регистра di на величину, равную длине элемента цепочки.
Знак этого изменения зависит от состояния флага df:</LI>

<UL>
<LI TYPE="SQUARE">
df=0 — увеличить, что означает просмотр от начала цепочки к ее концу;</LI>

<LI TYPE="SQUARE">
df=1 — уменьшить, что означает просмотр от конца цепочки к ее началу.</LI>
</UL>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команды сохраняют элемент из регистров al/ax/eax в ячейку памяти. Перед
командой stos можно указать префикс повторения rep, в этом случае появляется
возможность работы с блоками памяти, заполняя их значениями в соответствии
с содержимым регистра <I>ecx/cx</I>.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;заполнить некоторую область памяти пробелами
str&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Какая-то строка'
len_str=$-str
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,' '
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,str
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,len_str
rep&nbsp;&nbsp;&nbsp;&nbsp; stosb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;заполняем пробелами строку str
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
&nbsp;
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;пример совместной работы stosb и lodsb:
;копировать одну строку в другую до первого пробела
str1&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Какая-то строка'
len_str1=$-str
str2&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len_str1 dup (' ')
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,len_str1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,str1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,str2
m1:&nbsp;&nbsp;&nbsp;&nbsp; lodsb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; al,' '
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp; ;выход, если пробел
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stosb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop&nbsp;&nbsp;&nbsp; m1
exit:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 11 и команды <A HREF="#ins">ins/insb/insw/insd</A>,
<A HREF="#cmps">cmps/cmpsb/cmpsw/cmpsd</A>, <A HREF="#movs">movs/movsb/movsw/movsd,</A>
<A HREF="#outs">outs</A>, <A HREF="#scas">scas/scasb/scasw/scasd</A>, <A HREF="#lods">lods/lodsb/lodsw/lodsd</A>,
<A HREF="#rep">rep/repe/repz/repne/repnz</A>
<BR><A NAME="sub"></A>
<CENTER>
<H2>
SUB</H2></CENTER>

<CENTER><FONT SIZE=+1>(SUBtract)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Вычитание</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>sub операнд_1,операнд_2&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> целочисленное вычитание.

<P><I><A HREF="../Pic/P_2_103.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить вычитание операнд_1=операнд_2-операнд_1;</LI>

<LI>
установить флаги.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда sub используется для выполнения вычитания целочисленных операндов
или для вычитания младших частей значений многобайтных операндов.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;выполнить вычитание 64-битных значений: vich_1-vich_2
vich_1&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 dup (0)
vich_2&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 dup (0)
rez&nbsp;&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 dup (0)
...
;ввести значения в поля vich_1 и vich_2:
;младший байт по младшему адресу
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,vich_1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; eax,vich_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;вычесть младшие половинки чисел
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; rez,eax ;младшая часть результата
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,vich_1+4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sbb&nbsp;&nbsp;&nbsp;&nbsp; eax,vich_2+4&nbsp;&nbsp;&nbsp; ;вычесть старшие половинки чисел
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; rez+4,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;старшая часть результата
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 8, приложение 7 и команду <A HREF="#sbb">sbb</A>
<BR><A NAME="test"></A>
<CENTER>
<H2>
TEST</H2></CENTER>

<CENTER><FONT SIZE=+1>(TEST operand)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Логическое И</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>test приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> операция логического сравнения операндов приемник и
источник размерностью байт, слово или двойное слово.

<P><I><A HREF="../Pic/P_2_104.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить операцию логического умножения над операндами приемник и источник:
бит результата равен 1, если соответствующие биты операндов равны 1, в
остальных случаях бит результата равен 0;</LI>

<LI>
установить флаги.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>0</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда test используется для логического умножения двух операндов.
Результат операции, в отличие от команды and, никуда не записывается, устанавливаются
только флаги. Эту команду удобно использовать для получения информации
о состоянии заданных битов операнда приемник. Для анализа результата используется
флаг zf, который равен 1, если результат логического умножения равен нулю.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp;&nbsp; al,01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnz&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если нулевой бит al равен 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#or">or</A>, <A HREF="#xor">xor</A>,
<A HREF="#and">and</A>, <A HREF="#bt">bt</A>
<BR><A NAME="xadd"></A>
<CENTER>
<H2>
XADD</H2></CENTER>

<CENTER><FONT SIZE=+1>(eXchange and ADD)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Обмен и сложение</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>xadd приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> суммирование и обмен двух значений.

<P><I><A HREF="../Pic/P_2_105.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
копировать содержимое операнда приемник в операнд источник;</LI>

<LI>
выполнить сложение (приемник+источник);</LI>

<LI>
поместить сумму в операнд приемник.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r</TD>

<TD>r&nbsp;</TD>

<TD>r</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда xadd используется для выполнения операции обмена и сложения
двух операндов.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,08h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl,01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xadd&nbsp;&nbsp;&nbsp; al,bl&nbsp;&nbsp; ;al=09h, bl=08h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> уроки 7, 8 и команды <A HREF="#add">add</A>, <A HREF="#xchg">xchg</A>
<BR><A NAME="xchg"></A>
<CENTER>
<H2>
XCHG</H2></CENTER>

<CENTER><FONT SIZE=+1>(eXCHanGe)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Обмен</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>xchg операнд_1,операнд_2&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> обмен двух значений между регистрами или между регистрами
и памятью.

<P><I><A HREF="../Pic/P_2_106.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BR>обмен содержимого операнд_1 и операнд_2.

<P><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду xchg можно использовать для выполнения операции обмена двух
операндов с целью изменения порядка следования байт, слов, двойных слов
или их временного сохранения в регистре или памяти. Альтернативой является
использование для этой цели стека.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;поменять порядок следования байт в слове
ch1&nbsp;&nbsp;&nbsp;&nbsp; label&nbsp;&nbsp; byte
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0f85ch
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,ch1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xchg&nbsp;&nbsp;&nbsp; ch1+1,al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ch1,al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 7 и команды <A HREF="#bswap">bswap</A>, <A HREF="#cmpxchg">cmpxchg</A>,
<A HREF="#xadd">xadd</A>
<BR><A NAME="xlatb"></A>
<CENTER>
<H2>
XLAT/XLATB</H2></CENTER>

<CENTER><FONT SIZE=+1>(transLATe Byte from table)</FONT></CENTER>

<CENTER><FONT SIZE=+1>Преобразование байта</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>xlat адрес_таблицы_байтов xlatb&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> подмена байта в регистре al байтом из последовательности
(таблицы) байтов в памяти.

<P><I><A HREF="../Pic/P_2_107.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<BLOCKQUOTE>
<LI>
вычислить адрес, равный ds:bx+(al);</LI>

<LI>
выполнить замену байта в регистре al байтом из памяти по вычисленному адресу.</LI>
</BLOCKQUOTE>
Несмотря на наличие операнда адрес_таблицы_байтов в команде xlat, адрес
последовательности байтов, из которой будет осуществляться выборка байта
для подмены в регистре al, должен быть предварительно загружен в пару ds:bx(ebx).
Команда xlat допускает замену сегмента.

<P><I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>выполнение команды не влияет на флаги</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команду xlat можно использовать для выполнения перекодировок символов.
Для формирования адреса таблицы в регистрах bx(ebx) можно использовать
команду lea или оператор ассемблера offset в команде mov.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">table&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'abcdef'
int&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;значение индекса
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; bx,table
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xlat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;(al)='c'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 7 и команду <A HREF="#lea">lea</A>
<BR><A NAME="xor"></A>
<CENTER>
<H2>
XOR</H2></CENTER>

<CENTER><FONT SIZE=+1>Логическое исключающее ИЛИ</FONT></CENTER>

<CENTER><FONT SIZE=+1>ASCII-коррекция после сложения</FONT></CENTER>
&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT WIDTH="150"><I>Схема команды:&nbsp;</I></TD>

<TD ALIGN=CENTER WIDTH="250"><FONT SIZE=+0>xor приемник,источник&nbsp;</FONT></TD>
</TR>
</TABLE>
<I>Назначение:</I> операция логического исключающего ИЛИ над двумя операндами
размерностью байт, слово или двойное слово.

<P><I><A HREF="../Pic/P_2_108.gif" TARGET="M2">Синтаксис</A></I>
<BR><I>Алгоритм работы:</I>
<UL>
<LI>
выполнить операцию логического исключающего ИЛИ над операндами: бит результата
равен 1, если значения соответствующих битов операндов различны, в остальных
случаях бит результата равен 0;</LI>

<LI>
записать результат сложения в приемник;</LI>

<LI>
установить флаги.</LI>
</UL>
<I>Состояние флагов после выполнения команды:</I>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>11</TD>

<TD>07</TD>

<TD>06</TD>

<TD>04</TD>

<TD>02</TD>

<TD>00</TD>
</TR>

<TR>
<TD>OF</TD>

<TD>SF</TD>

<TD>ZF</TD>

<TD>AF</TD>

<TD>PF</TD>

<TD>CF</TD>
</TR>

<TR>
<TD>0</TD>

<TD>r</TD>

<TD>r</TD>

<TD>?</TD>

<TD>r&nbsp;</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<I>Применение:</I>
<BR>Команда xor используется для выполнения операции логического исключающего
ИЛИ двух операндов. Результат операции помещается в первый операнд. Эту
операцию удобно использовать для инвертирования или сравнения определенных
битов операндов.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">;изменить значение бита 0 регистра al на обратное
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; al,01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<I>См. также:</I> урок 9 и команды <A HREF="#and">and</A>, <A HREF="#or">or</A>,
<A HREF="#not">not</A>
<BR>
<HR SIZE=5 WIDTH=80%>
</BODY>
</HTML>
