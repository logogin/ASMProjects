<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE>Логические команды</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF">
<!базовый размер символов (для всего документа><!тело html-документа><!C-HR SIZE=5 WIDTH=60%><A NAME="СредстваЛогическойОбработкиДанных"></A>
<H2>
Логические команды</H2>
<FONT SIZE=+0>Наряду со средствами арифметических вычислений, система команд
микропроцессора имеет также средства логического преобразования данных.
Под логическими понимаются такие преобразования данных, в основе которых
лежат <I>правила формальной логики</I>.</FONT>
<BR><FONT SIZE=+0>Формальная логика работает на уровне утверждений <B>истинно</B>
и <B>ложно</B>. Для микропроцессора это, как правило, означает <B>1</B>
и <B>0</B> соответственно.</FONT>
<BR><FONT SIZE=+0>Для компьютера язык нулей и единиц является родным, но
минимальной единицей данных, с которой работают машинные команды, является
<I>байт</I>. Однако, на системном уровне часто необходимо иметь возможность
работать на предельно низком уровне — на уровне <I>бит</I>.&nbsp;</FONT><A NAME="ОперацииСредстваЛогическойОбработкиДанных"></A>

<P><CENTER><IMG SRC="Ris9_01.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<P><FONT SIZE=+0>К средствам логического преобразования данных относятся
логические команды и <I><A HREF="../../Text/Structur.htm#ОператорыСдвига">логические
операции</A></I>.</FONT>
<BR><FONT SIZE=+0>В связи с последним напомню, что операнд команды ассемблера
в общем случае может представлять собой выражение, которое, в свою очередь,
является комбинаций операторов и операндов. Среди этих операторов могут
быть и операторы, реализующие логические операции над объектами выражения.</FONT>

<P><FONT SIZE=+0>Перед подробным рассмотрением этих средств давайте посмотрим,
что же представляют собой сами <I>логические данные</I> и какие операции
над ними производятся.</FONT>
<H3>
<FONT SIZE=+0>Логические данные</FONT></H3>
<FONT SIZE=+0>Теоретической базой для логической обработки данных является
<I>формальная логика</I>.</FONT>
<BR><FONT SIZE=+0>Существует несколько систем логики. Одна из наиболее
известных — это <I>исчисление высказываний</I>. <B>Высказывание</B> — это
любое утверждение, о котором можно сказать, что оно либо <I>истинно,</I>
либо <I>ложно</I>.</FONT>
<BR><FONT SIZE=+0>Исчисление высказываний представляет собой совокупность
правил, используемых для определения истинности или ложности некоторой
комбинации высказываний.</FONT>

<P><FONT SIZE=+0>Исчисление высказываний очень гармонично сочетается с
принципами работы компьютера и основными методами его программирования.
Все аппаратные компоненты компьютера построены на логических микросхемах.
Система представления информации в компьютере на самом нижнем уровне основана
на понятии бита. Бит, имея всего два состояния: 0 (ложно) и 1 (истинно),
</FONT>—<FONT SIZE=+0> естественным образом вписывается в исчисление высказываний.</FONT>

<P><FONT SIZE=+0>Согласно теории, над высказываниями (над битами) могут
выполняться следующие логические операции:</FONT>
<UL>
<LI>
<FONT SIZE=+0><A HREF="#Отрицание">отрицание (логическое НЕ);</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ЛогическоеСложение">логическое сложение (логическое
включающее ИЛИ);</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ЛогическоеУмножение">логическое умножение (логическое
И);</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ЛогическоеИсключающееСложение">логическое исключающее
сложение (логическое исключающее ИЛИ).</A></FONT></LI>
</UL>

<UL><A NAME="Отрицание"></A>
<LI>
<FONT SIZE=+0><B>отрицание</B> (логическое <I>НЕ</I>) — логическая операция
над одним операндом, результатом которой является величина, обратная значению
исходного операнда.</FONT></LI>

<BR><FONT SIZE=+0>Эта операция однозначно характеризуется следующей таблицей
истинности (табл. 1).</FONT>

<P><FONT SIZE=+0><B>Таблица 1.</B> Таблица истинности для логического отрицания</FONT>
<P><CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>Значение операнда</TD>

<TD>0</TD>

<TD>1</TD>
</TR>

<TR>
<TD>Результат операции</TD>

<TD>1</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
<P>
<A NAME="ЛогическоеСложение"></A>
<LI>
<P><FONT SIZE=+0><B>логическое сложение</B> (логическое включающее <I>ИЛИ</I>)
</FONT>—<FONT SIZE=+0> логическая операция над двумя операндами, результатом
которой является “истина” (1), если один или оба операнда имеют значение
“истина” (1), и “ложь” (0) — если оба операнда имеют значение “ложь” (0).</FONT></LI>

<BR><FONT SIZE=+0>Эта операция описывается с помощью следующей таблицы
истинности (табл. 2).</FONT>

<P><FONT SIZE=+0><B>Таблица 2.</B> Таблица истинности для логического включающего
ИЛИ</FONT>
<P><CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>Значение операнда 1</TD>

<TD>0</TD>

<TD>0</TD>

<TD>1</TD>

<TD>1</TD>
</TR>

<TR>
<TD>Значение операнда 2</TD>

<TD>0</TD>

<TD>1</TD>

<TD>0</TD>

<TD>1</TD>
</TR>

<TR>
<TD>Результат операции</TD>

<TD>0</TD>

<TD>1</TD>

<TD>1</TD>

<TD>1</TD>
</TR>
</TABLE></CENTER>
<P>
<A NAME="ЛогическоеУмножение"></A>
<LI>
<P><FONT SIZE=+0><B>логическое умножение</B> (логическое <I>И</I>) — логическая
операция над двумя операндами, результатом которой является “истина” (1)
только в том случае, если оба операнда имеют значение “истина” (1). Во
всех остальных случаях значение операции “ложь” (0).</FONT></LI>

<BR><FONT SIZE=+0>Эта операция описывается с помощью следующей таблицы
истинности (табл.3).</FONT>

<P><FONT SIZE=+0><B>Таблица 3.</B> Таблица истинности для логического И</FONT>
<P><CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>Значение операнда 1</TD>

<TD>0</TD>

<TD>0</TD>

<TD>1</TD>

<TD>1</TD>
</TR>

<TR>
<TD>Значение операнда 2</TD>

<TD>0</TD>

<TD>1</TD>

<TD>0</TD>

<TD>1</TD>
</TR>

<TR>
<TD>Результат операции</TD>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD>1</TD>
</TR>
</TABLE></CENTER>
<P>
<A NAME="ЛогическоеИсключающееСложение"></A>
<LI>
<P><FONT SIZE=+0><B>логическое исключающее сложение</B> (логическое исключающее
<I>ИЛИ</I>) — логическая операция над двумя операндами, результатом которой
является “истина” (1), если только один из двух операндов имеет значение
“истина” (1), и ложь (0), если оба операнда имеют значение “ложь” (0) или
“истина” (1).</FONT></LI>

<BR><FONT SIZE=+0>Эта операция описывается с помощью следующей таблицы
истинности(табл. 4).</FONT>

<P><B><FONT SIZE=+0>Таблица 4.</FONT></B><FONT SIZE=+0> Таблица истинности
для логического исключающего ИЛИ</FONT>
<P><CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>Значение операнда 1</TD>

<TD>0</TD>

<TD>0</TD>

<TD>1</TD>

<TD>1</TD>
</TR>

<TR>
<TD>Значение операнда 2</TD>

<TD>0</TD>

<TD>1</TD>

<TD>0</TD>

<TD>1</TD>
</TR>

<TR>
<TD>Результат операции</TD>

<TD>0</TD>

<TD>1</TD>

<TD>1</TD>

<TD>0</TD>
</TR>
</TABLE></CENTER>
&nbsp;</UL>
<P><FONT SIZE=+0>Система команд микропроцессора содержит пять команд, поддерживающих
данные операции. Эти команды выполняют логические операции над битами операндов.
Размерность операндов, естественно, должна быть одинакова. Например, если
размерность операндов равна слову (16 бит), то логическая операция выполняется
сначала над нулевыми битами операндов и ее результат записывается на место
бита 0 результата. Далее команда последовательно повторяет эти действия
над всеми битами с первого до пятнадцатого. Возможные варианты размерности
операндов для каждой команды приведены в “Справочнике команд”.&nbsp;</FONT><A NAME="Логические"></A>
<H3>
<FONT SIZE=+0>Логические команды</FONT></H3>
<FONT SIZE=+0>В системе команд микропроцессора есть следующий набор команд,
поддерживающих работу с логическими данными:</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#and">and</A></B>
<B>операнд_1,операнд_2</B> — операция логического умножения.</FONT>
<BR><FONT SIZE=+0>Команда выполняет поразрядно логическую операцию И (конъюнкцию)
над битами операндов операнд_1 и операнд_2. Результат записывается на место
операнд_1.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#or">or</A></B>
<B>операнд_1,операнд_2</B> — операция логического сложения.</FONT>
<BR><FONT SIZE=+0>Команда выполняет поразрядно логическую операцию ИЛИ
(дизъюнкцию) над битами операндов операнд_1 и операнд_2. Результат записывается
на место операнд_1.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#xor">xor</A></B>
<B>операнд_1,операнд_2</B> — операция логического исключающего сложения.</FONT>
<BR><FONT SIZE=+0>Команда выполняет поразрядно логическую операцию исключающего
ИЛИ над битами операндов операнд_1 и операнд_2. Результат записывается
на место операнд_1.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#test">test</A></B>
<B>операнд_1,операнд_2</B> — операция “проверить” (способом логического
умножения).</FONT>
<BR><FONT SIZE=+0>Команда выполняет поразрядно логическую операцию И над
битами операндов операнд_1 и операнд_2. Состояние операндов остается прежним,
изменяются только флаги zf, sf, и pf, что дает возможность анализировать
состояние отдельных битов операнда без изменения их состояния.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#not">not</A></B>
<B>операнд</B> — операция логического отрицания.</FONT>
<BR><FONT SIZE=+0>Команда выполняет поразрядное инвертирование (замену
значения на обратное) каждого бита операнда. Результат записывается на
место операнда.</FONT>

<P><FONT SIZE=+0>Для представления роли логических команд в системе команд
микропроцессора очень важно понять области их применения и типовые приемы
их использования при программировании.</FONT>
<BR><FONT SIZE=+0>С помощью логических команд возможно <I>выделение</I>
отдельных битов в операнде с целью их <I>установки, сброса, инвертирования
или просто проверки на определенное значение</I>.</FONT>
<BR><FONT SIZE=+0>Для организации подобной работы с битами <I>операнд_2</I>
обычно играет роль <B>маски</B>. С помощью установленных в 1 битов этой
маски и определяются нужные для конкретной операции биты операнд_1. Покажем,
какие логические команды могут применяться для этой цели:</FONT>
<UL>
<LI>
<FONT SIZE=+0>Для <B>установки</B> определенных разрядов (бит) в <B>1</B>
применяется команда</FONT></LI>

<BR><FONT SIZE=+0><B>or операнд_1,операнд_2</B>.</FONT>
<BR><FONT SIZE=+0>В этой команде операнд_2, выполняющий роль маски, должен
содержать единичные биты на месте тех разрядов, которые должны быть установлены
в 1 в операнд_1.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,10b ;установить 1-й бит в регистре eax
&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<LI>
<FONT SIZE=+0>Для <B>сброса</B> определенных разрядов (бит) в <B>0</B>
применяется команда</FONT></LI>

<BR><FONT SIZE=+0><B>and операнд_1,операнд_2</B>.</FONT>
<BR><FONT SIZE=+0>В этой команде операнд_2, выполняющий роль маски, должен
содержать нулевые биты на месте тех разрядов, которые должны быть установлены
в 0 в операнд_1.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; eax,fffffffdh&nbsp;&nbsp; ;сбросить в 0 1-й бит в регистре eax
&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<LI>
<FONT SIZE=+0>Команда <B>xor операнд_1,операнд_2</B> применяется:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>для выяснения того, какие биты в операнд_1 и операнд_2 <B>различаются</B>;</FONT></LI>

<LI>
<FONT SIZE=+0>для <B>инвертирования</B> состояния заданных бит в операнд_1.</FONT></LI>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; eax,10b ;инвертировать 1-й бит в регистре eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mes&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если 1-й бит в al был единичным
&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
&nbsp;</UL>


<P><FONT SIZE=+0>Интересующие нас биты маски (операнд_2) при выполнении
команды xor должны быть единичными, остальные </FONT>—<FONT SIZE=+0> нулевыми.</FONT>
<LI>
<FONT SIZE=+0>Для проверки состояния заданных бит применяется команда</FONT></LI>

<BR><FONT SIZE=+0><B>test операнд_1,операнд_2</B> (проверить операнд_1).</FONT>
<BR><FONT SIZE=+0>Проверяемые биты операнд_1 в маске (операнд_2) должны
иметь единичное значение. Алгоритм работы команды test подобен алгоритму
команды and, но он не меняет значения операнд_1.</FONT>
<BR><FONT SIZE=+0>Результатом команды является установка значения флага
нуля <B>zf</B>:</FONT>
<UL>
<LI>
<FONT SIZE=+0>если <I>zf</I> = 0, то в результате логического умножения
получился нулевой результат, то есть один единичный бит маски, который
<B>не совпал</B> с соответствующим единичным битом операнд_1;</FONT></LI>

<LI>
<FONT SIZE=+0>если <I>zf</I> = 1, то в результате логического умножения
получился ненулевой результат, то есть <I>хотя бы один</I> единичный бит
маски <B>совпал</B> с соответствующим единичным битом операнд_1.</FONT></LI>
</UL>
&nbsp;
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp;&nbsp; eax,00000010h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если 4-й бит равен 1
&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
&nbsp;</UL>


<P><FONT SIZE=+0>Как видно из примера, для реакции на результат команды
test целесообразно использовать команду перехода <A HREF="../../Text/Command.htm#jcc">jnz</A>
метка (Jump if Not Zero) — переход, если флаг нуля zf ненулевой, или команду
с обратным действием — <A HREF="../../Text/Command.htm#jcc">jz</A>
метка (Jump if Zero) </FONT>—<FONT SIZE=+0> переход, если флаг нуля zf
= 0.&nbsp;</FONT><A NAME="СканированияБит"></A><A NAME="МанипуляцииБитами"></A><A NAME="ОбработкиБит"></A>

<P><FONT SIZE=+0>Следующие две команды позволяют осуществить поиск первого
установленного в 1 бита операнда. Поиск можно произвести как с начала так
и от конца операнда:</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#bsf">bsf</A></B>
<B>операнд_1,операнд_2</B> (Bit Scaning Forward) - сканирование битов вперед.</FONT>
<BR><FONT SIZE=+0>Команда просматривает (сканирует) биты операнд_2 от младшего
к старшему (от бита 0 до старшего бита) в поисках первого бита, установленного
в 1. Если таковой обнаруживается, в операнд_1 заносится номер этого бита
в виде целочисленного значения. Если все биты операнд_2 равны 0, то флаг
нуля zf устанавливается в 1, в противном случае флаг zf сбрасывается в
0.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,02h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsf&nbsp;&nbsp;&nbsp;&nbsp; bx,al&nbsp;&nbsp; ;bx=1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если al=00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><B><A HREF="../../Text/Command.htm#bsr">bsr</A></B>
<B>операнд_1,операнд_2</B> (Bit Scaning Reset) — сканирование битов в обратном
порядке.</FONT>
<BR><FONT SIZE=+0>Команда просматривает (сканирует) биты операнд_2 от старшего
к младшему (от старшего бита к биту 0) в поисках первого бита, установленного
в 1. Если таковой обнаруживается, в операнд_1 заносится номер этого бита
в виде целочисленного значения.</FONT>
<BR><FONT SIZE=+0>При этом важно, что позиция первого единичного бита слева
отсчитывается все равно относительно бита 0. Если все биты операнд_2 равны
0, то флаг нуля zf устанавливается в 1, в противном случае флаг zf сбрасывается
в 0.</FONT>

<P><FONT SIZE=+0>Листинг 1 демонстрирует пример применения команд bsr и
bsf. Введите код и исследуйте работу программы в отладчике (в частности,
обратите внимание на то, как меняется содержимое регистра bx после команд
bsf и bsr).</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;Листинг 1 Сканирование битов
;prg_9_1.asm
masm
model&nbsp;&nbsp; small
stack&nbsp;&nbsp; 256
.data&nbsp;&nbsp; ;сегмент данных
.code&nbsp;&nbsp; ;сегмент кода
main:&nbsp;&nbsp; ;точка входа в программу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
;...
.486&nbsp;&nbsp;&nbsp; ;это обязательно
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; ax,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,02h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsf&nbsp;&nbsp;&nbsp;&nbsp; bx,ax&nbsp;&nbsp; ;bx=1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если al=00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsr&nbsp;&nbsp;&nbsp;&nbsp; bx,ax
m1:
;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;стандартный выход
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
end&nbsp;&nbsp;&nbsp;&nbsp; main
&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<A NAME="ПроверкиМодификацииБит"></A>

<P><FONT SIZE=+0>В последних моделях микропроцессоров Intel в группе логических
команд появилось еще несколько команд, которые позволяют осуществить доступ
к одному конкретному биту операнда. Операнд может находиться как в памяти,
так и в регистре общего назначения. Положение бита задается смещением бита
относительно младшего бита операнда. Значение смещения может задаваться
как в виде непосредственного значения, так и содержаться в регистре общего
назначения. В качестве значения смещения вы можете использовать результаты
работы команд bsr и bsf. Все команды присваивают значение выбранного бита
флагу cf.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#bt">bt</A></B>
<B>операнд,смещение_бита</B> (Bit Test) — проверка бита.</FONT>
<BR><FONT SIZE=+0>Команда переносит значение бита в флаг cf.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ax,5&nbsp;&nbsp;&nbsp; ;проверить значение бита 5
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnc&nbsp;&nbsp;&nbsp;&nbsp; m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;переход, если бит = 0
&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><B><A HREF="../../Text/Command.htm#bts">bts</A></B>
<B>операнд,смещение_бита</B> (Bit Test and Set) — проверка и установка
бита.</FONT>
<BR><FONT SIZE=+0>Команда переносит значение бита в флаг cf и затем устанавливает
проверяемый бит в 1.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax,10
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bts&nbsp;&nbsp;&nbsp;&nbsp; pole,ax ;проверить и установить 10-й бит в pole
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jсm1&nbsp;&nbsp;&nbsp; ;переход, если проверяемый бит был равен 1</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><B><A HREF="../../Text/Command.htm#btr">btr</A></B>
<B>операнд,смещение_бита</B> (Bit Test and Reset) — проверка и сброс бита.</FONT>
<BR><FONT SIZE=+0>Команда переносит значение бита в флаг cf и затем устанавливает
этот бит в 0.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#btc">btc</A></B>
<B>операнд,смещение_бита</B> (Bit Test and Convert) — проверка и инвертирование
бита.</FONT>
<BR><FONT SIZE=+0>Команда переносит значение бита в флаг cf и затем инвертирует
значение этого бита.&nbsp;</FONT><A NAME="Сдвига"></A>
<H3>
<FONT SIZE=+0>Команды сдвига</FONT></H3>
<FONT SIZE=+0>Команды этой группы также обеспечивают манипуляции над отдельными
битами операндов, но иным способом, чем логические команды, рассмотренные
выше.</FONT>
<BR><FONT SIZE=+0>Все команды сдвига перемещают биты в поле операнда влево
или вправо в зависимости от кода операции.</FONT>
<BR><FONT SIZE=+0>Все команды сдвига имеют одинаковую структуру:</FONT>

<P><FONT SIZE=+0><B>коп операнд,счетчик_сдвигов</B></FONT>

<P><FONT SIZE=+0>Количество сдвигаемых разрядов </FONT>—<FONT SIZE=+0>
<I>счетчик_сдвигов </I></FONT>—<FONT SIZE=+0> располагается, как видите,
на месте второго операнда и может задаваться двумя способами:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>статически</I>, что предполагает задание фиксированного
значения с помощью непосредственного операнда;</FONT></LI>

<LI>
<FONT SIZE=+0><I>динамически</I>, что означает занесение значения счетчика
сдвигов в регистр cl перед выполнением команды сдвига.</FONT></LI>
</UL>


<P><FONT SIZE=+0>Исходя из размерности регистра cl, понятно, что значение
счетчика сдвигов может лежать в диапазоне от 0 до 255. Но на самом деле
это не совсем так.</FONT>
<BR><FONT SIZE=+0>В целях оптимизации микропроцессор воспринимает только
значение <I>пяти младших битов</I> счетчика, то есть значение лежит в диапазоне
от 0 до 31.</FONT>
<BR><FONT SIZE=+0>В последних моделях микропроцессора, в том числе и в
микропроцессоре Pentium, есть дополнительные команды, позволяющие делать
64-разрядные сдвиги. Мы их рассмотрим чуть позже.</FONT>

<P><FONT SIZE=+0>Все команды сдвига устанавливают флаг переноса <B>cf</B>.</FONT>
<BR><FONT SIZE=+0>По мере сдвига битов за пределы операнда они сначала
попадают на флаг переноса, устанавливая его равным значению очередного
бита, оказавшегося за пределами операнда. Куда этот бит попадет дальше,
зависит от типа команды сдвига и алгоритма программы.</FONT>

<P><FONT SIZE=+0>По принципу действия команды сдвига можно разделить на
два типа:</FONT>
<UL>
<LI>
<FONT SIZE=+0><A HREF="#ОбычногоСдвига">команды линейного сдвига;</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ЦиклическогоСдвига">команды циклического сдвига.</A></FONT></LI>
</UL>
<A NAME="ОбычногоСдвига"></A>
<H4>
<FONT SIZE=+0>Команды линейного сдвига</FONT></H4>
<FONT SIZE=+0>К командам этого типа относятся команды, осуществляющие сдвиг
по следующему алгоритму:</FONT>
<UL>
<LI>
<FONT SIZE=+0>очередной “выдвигаемый” бит устанавливает флаг cf;</FONT></LI>

<LI>
<FONT SIZE=+0>бит, вводимый в операнд с другого конца, имеет значение 0;</FONT></LI>

<LI>
<FONT SIZE=+0>при сдвиге очередного бита он переходит во флаг cf, при этом
значение предыдущего сдвинутого бита <B><I>теряется!</I></B></FONT></LI>
</UL>
<FONT SIZE=+0>Команды линейного сдвига делятся на два подтипа:</FONT>
<UL>
<LI>
<FONT SIZE=+0>команды логического линейного сдвига;</FONT></LI>

<LI>
<FONT SIZE=+0>команды арифметического линейного сдвига.</FONT></LI>
</UL>
<FONT SIZE=+0>·</FONT>

<P><FONT SIZE=+0>К командам <I>логического</I> линейного сдвига относятся
следующие:</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#shl">shl</A></B>
<B>операнд,счетчик_сдвигов </B>(Shift Logical Left) - логический сдвиг
влево.</FONT>
<BR><FONT SIZE=+0>Содержимое операнда сдвигается влево на количество битов,
определяемое значением счетчик_сдвигов. Справа (в позицию младшего бита)
вписываются нули;</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#shr">shr</A></B>
<B>операнд,счетчик_сдвигов </B>(Shift Logical Right) — логический сдвиг
вправо.</FONT>
<BR><FONT SIZE=+0>Содержимое операнда сдвигается вправо на количество битов,
определяемое значением счетчик_сдвигов. Слева (в позицию старшего, знакового
бита) вписываются нули. На рис. 1 показан принцип работы этих команд.</FONT>

<P><CENTER><IMG SRC="Ris9_02.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 1. </B>Схема работы команд линейного логического
сдвига</FONT></I></CENTER>


<P><FONT SIZE=+0>Ниже показан фрагмент программы, который выполняет преобразование
двух неупакованных BCD-чисел в слове памяти bcd_dig в упакованное BCD-число
в регистре al.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
bcd_dig dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0905h&nbsp;&nbsp; ;описание неупакованного BCD-числа 95
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,bcd_dig&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;пересылка
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp; ah,4&nbsp;&nbsp;&nbsp; ;сдвиг влево
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; al,ah&nbsp;&nbsp; ;сложение для получения результата: al=95h</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Команды <I>арифметического</I> линейного сдвига отличаются
от команд <I>логического</I> сдвига тем, что они особым образом работают
со <I>знаковым разрядом</I> операнда.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#sal">sal</A></B>
<B>операнд,счетчик_сдвигов </B>(Shift Arithmetic Left) </FONT>—<FONT SIZE=+0>
арифметический сдвиг влево.</FONT>
<BR><FONT SIZE=+0>Содержимое операнда сдвигается влево на количество битов,
определяемое значением <I>счетчик_сдвигов</I>. Справа (в позицию младшего
бита) вписываются нули. Команда sal <B>не сохраняет знака</B>, но <I>устанавливает
флаг cf в случае смены знака</I> очередным выдвигаемым битом. В остальном
команда sal полностью аналогична команде shl;</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#sar">sar</A></B>
<B>операнд,счетчик_сдвигов </B>(Shift Arithmetic Right) — арифметический
сдвиг вправо.</FONT>
<BR><FONT SIZE=+0>Содержимое операнда сдвигается вправо на количество битов,
определяемое значением <I>счетчик_сдвигов</I>. Слева в операнд вписываются
нули. Команда sar <B>сохраняет знак</B>, восстанавливая его после сдвига
каждого очередного бита.</FONT>
<BR><FONT SIZE=+0>На рис. 2 показан принцип работы команд линейного арифметического
сдвига.</FONT>

<P><CENTER><IMG SRC="Ris9_03.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 2.</B> Схема работы команд линейного арифметического
сдвига&nbsp;</FONT></I><A NAME="ЦиклическогоСдвига"></A></CENTER>

<H4>
<FONT SIZE=+0>Команды циклического сдвига</FONT></H4>
<FONT SIZE=+0>К командам <I>циклического</I> сдвига относятся команды,
сохраняющие значения сдвигаемых бит. Есть два типа команд циклического
сдвига:</FONT>
<UL>
<LI>
<FONT SIZE=+0>команды простого циклического сдвига;</FONT></LI>

<LI>
<FONT SIZE=+0>команды циклического сдвига через флаг переноса cf.</FONT></LI>
</UL>
<FONT SIZE=+0>К командам <I>простого циклического</I> сдвига относятся:</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#rol">rol</A></B>
<B>операнд,счетчик_сдвигов </B>(Rotate Left) </FONT>—<FONT SIZE=+0> циклический
сдвиг влево.</FONT>
<BR><FONT SIZE=+0>Содержимое операнда сдвигается влево на количество бит,
определяемое операндом <I>счетчик_сдвигов</I>. Сдвигаемые влево биты записываются
в тот же операнд справа.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#ror">ror</A></B>
<B>операнд,счетчик_сдвигов </B>(Rotate Right) — циклический сдвиг вправо.</FONT>
<BR><FONT SIZE=+0>Содержимое операнда сдвигается вправо на количество бит,
определяемое операндом <I>счетчик_сдвигов</I>. Сдвигаемые вправо биты записываются
в тот же операнд слева.</FONT>

<P><CENTER><IMG SRC="Ris9_04.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 3. </B>Схема работы команд простого циклического
сдвига</FONT></I></CENTER>

<P><FONT SIZE=+0>Как видно из рис. 3, команды простого циклического сдвига
в процессе своей работы осуществляют одно полезное действие, а именно:
циклически сдвигаемый бит не только вдвигается в операнд с другого конца,
но и одновременно его значение становиться значением флага cf.</FONT>
<BR><FONT SIZE=+0>К примеру, для того чтобы обменять содержимое двух половинок
регистра eax, достаточно выполнить следующую последовательность команд:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,ffff0000h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cl,16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rol&nbsp;&nbsp;&nbsp;&nbsp; eax,cl</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Команды циклического сдвига <I>через флаг переноса cf</I>
отличаются от команд простого циклического сдвига тем, что сдвигаемый бит
не сразу попадает в операнд с другого его конца, а записывается сначала
в флаг переноса cf. <I>Лишь следующее исполнение данной команды сдвига
(при условии, что она выполняется в цикле) приводит к помещению выдвинутого
ранее бита с другого конца операнда</I> (см. рис. 4).</FONT>

<P><FONT SIZE=+0>К командам циклического сдвига <I>через флаг переноса
cf</I> относятся следующие:</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#rcl">rcl</A></B>
<B>операнд,счетчик_сдвигов </B>(Rotate through Carry Left) — циклический
сдвиг влево через перенос.</FONT>
<BR><FONT SIZE=+0>Содержимое операнда сдвигается влево на количество бит,
определяемое операндом <I>счетчик_сдвигов</I>. Сдвигаемые биты поочередно
становятся значением флага переноса cf.</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#rcr">rcr</A></B>
<B>операнд,счетчик_сдвигов </B>(Rotate through Carry Right) — циклический
сдвиг вправо через перенос.</FONT>
<BR><FONT SIZE=+0>Содержимое операнда сдвигается вправо на количество бит,
определяемое операндом <I>счетчик_сдвигов</I>. Сдвигаемые биты поочередно
становятся значением флага переноса cf.</FONT>

<P><CENTER><IMG SRC="Ris9_05.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<P><CENTER><B><FONT SIZE=+0><I>Рис. 4.</I> </FONT></B><FONT SIZE=+0><I>Команды
циклического сдвига через флаг переноса cf</I></FONT></CENTER>

<P><FONT SIZE=+0>Из рис. 4 видно, что при сдвиге через флаг переноса появляется
промежуточный элемент, с помощью которого, в частности, можно производить
подмену циклически сдвигаемых битов, в частности, <I>рассогласование</I>
битовых последовательностей.</FONT>
<BR><FONT SIZE=+0>Под рассогласованием битовой последовательности здесь
и далее подразумевается действие, которое позволяет некоторым образом локализовать
и извлечь нужные участки этой последовательности и записать их в другое
место.</FONT>
<H3>
<FONT SIZE=+0>Дополнительные команды сдвига</FONT></H3>
<FONT SIZE=+0>Система команд последних моделей микропроцессоров Intel,
начиная с i80386, содержит дополнительные команды сдвига, расширяющие возможности,
рассмотренные нами ранее.</FONT>
<BR><FONT SIZE=+0>Это — команды сдвигов <I>двойной точности</I>:</FONT>

<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#shld">shld</A></B>
<B>операнд_1,операнд_2,счетчик_сдвигов</B> — сдвиг влево двойной точности.</FONT>
<BR><FONT SIZE=+0>Команда shld производит замену путем сдвига битов операнда
операнд_1 влево, заполняя его биты справа значениями битов, вытесняемых
из операнд_2 согласно схеме на рис. 5. Количество сдвигаемых бит определяется
значением <I>счетчик_сдвигов</I>, которое может лежать в диапазоне <B>0...31</B>.
Это значение может задаваться непосредственным операндом или содержаться
в регистре cl. Значение операнд_2 не изменяется.</FONT>
<P><CENTER><IMG SRC="Ris9_06.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 5. </B>Схема работы команды shld</FONT></I></CENTER>

<FONT SIZE=+0><B><A HREF="../../Text/Command.htm#shrd">shrd</A></B>
<P><B>операнд_1,операнд_2,счетчик_сдвигов</B> — сдвиг вправо двойной точности.</FONT>
<BR><FONT SIZE=+0>Команда производит замену путем сдвига битов операнда
операнд_1 вправо, заполняя его биты слева значениями битов, вытесняемых
из операнд_2 согласно схеме на рис. 6. Количество сдвигаемых бит определяется
значением <I>счетчик_сдвигов</I>, которое может лежать в диапазоне <B>0...31</B>.
Это значение может задаваться непосредственным операндом или содержаться
в регистре cl. Значение операнд_2 не изменяется.</FONT>
<P><CENTER><IMG SRC="Ris9_07.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 6. </B>Схема работы команды shrd</FONT></I></CENTER>


<P><FONT SIZE=+0>Как мы отметили, команды shld и shrd осуществляют сдвиги
до 32 разрядов, но за счет особенностей задания операндов и алгоритма работы
эти команды можно использовать для работы с полями длиной до 64 бит.</FONT>
<BR><FONT SIZE=+0>Например, рассмотрим, как можно осуществить сдвиг влево
на 16 бит поля из 64 бит.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
;...
.data
pole_l&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0b21187f5h1
pole_h&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45ff6711h
.code
;...
.386
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cl,16&nbsp;&nbsp; ;загрузка счетчика сдвига в cl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,pole_h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shld&nbsp;&nbsp;&nbsp; pole_l,eax,cl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp; pole_h,cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;pole_l=87f50000h, pole_h=6711b211h</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<HR SIZE=5 WIDTH=80%>
</BODY>
<!конец html-документа>
</HTML>
