<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE>Из урока 7</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF">
<!базовый размер символов (для всего документа><!тело html-документа>
<HR SIZE=5 WIDTH=60%><A NAME="ПересылкиДанных"></A>
<H3>
<FONT SIZE=+0>Команды пересылки данных</FONT></H3>
<FONT SIZE=+0>Для удобства практического применения и отражения их специфики
команды данной группы удобнее рассматривать в соответствии с их функциональным
назначением, согласно которому их можно разбить на следующие группы команд:</FONT>
<UL>
<LI>
<FONT SIZE=+0><A HREF="#ОбщегоНазначения">пересылки данных общего назначения</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ВводаВыводаВПорт">ввода-вывода в порт</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#РаботыСАдресамиИУказателями">работы с адресами
и указателями</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ПреобразованияДанных">преобразования данных</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#РаботыСоСтеком">работы со стеком</A></FONT></LI>
</UL>
<A NAME="ОбщегоНазначения"></A>
<H4>
<FONT SIZE=+0>Команды пересылки данных общего назначения</FONT></H4>
<FONT SIZE=+0>К этой группе относятся следующие команды:</FONT>
<BR><FONT SIZE=+0><B>mov &lt;операнд назначения>,&lt;операнд-источник></B></FONT>
<BR><FONT SIZE=+0><B>xchg &lt;операнд1>,&lt;операнд2></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#mov" TARGET="M3">mov</A></B>
- это основная команда пересылки данных. Она реализует самые разнообразные
варианты пересылки.</FONT>
<BR><FONT SIZE=+0>Отметим особенности применения этой команды:</FONT>
<UL>
<LI>
<FONT SIZE=+0>командой <I>mov</I> нельзя осуществить пересылку из одной
области памяти в другую. Если такая необходимость возникает, то нужно использовать
в качестве промежуточного буфера любой доступный в данный момент регистр
общего назначения.</FONT></LI>

<BR><FONT SIZE=+0>К примеру, рассмотрим фрагмент программы для пересылки
байта из ячейки fls в ячейку fld:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
masm
model&nbsp;&nbsp; small
.data
fls&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5
fld&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
.code
start:
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,fls
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; fld,al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
end&nbsp;&nbsp;&nbsp;&nbsp; start</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<LI>
<FONT SIZE=+0>нельзя загрузить в сегментный регистр значение непосредственно
из памяти. Поэтому для выполнения такой загрузки нужно использовать промежуточный
объект. Это может быть регистр общего назначения или стек. Если вы посмотрите
листинги 3.1 и 5.1, то увидите в начале сегмента кода две команды <I>mov</I>,
выполняющие настройку сегментного регистра ds. При этом из-за невозможности
загрузить впрямую в сегментный регистр значение адреса сегмента, содержащееся
в предопределенной переменной @data, приходится использовать регистр общего
назначения ax;</FONT></LI>

<LI>
<FONT SIZE=+0>нельзя переслать содержимое одного сегментного регистра в
другой сегментный регистр. Это объясняется тем, что в системе команд нет
соответствующего кода операции. Но необходимость в таком действии часто
возникает. Выполнить такую пересылку можно, используя в качестве промежуточных
все те же регистры общего назначения. Вот пример инициализации регистра
es значением из регистра ds:</FONT></LI>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,ds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax</FONT></TT></PRE>
</TD>
</TR>
</TABLE>


<P><FONT SIZE=+0>Но есть и другой, более красивый способ выполнения данной
операции — использование стека и команд push и pop:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;поместить значение регистра ds в стек
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;записать в es число из стека</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<LI>
<FONT SIZE=+0>нельзя использовать сегментный регистр cs в качестве операнда
назначения. Причина здесь простая. Дело в том, что в архитектуре микропроцессора
пара cs:ip всегда содержит адрес команды, которая должна выполняться следующей.
Изменение командой <I>mov</I> содержимого регистра cs фактически означало
бы операцию перехода, а не пересылки, что недопустимо.</FONT></LI>
</UL>
<FONT SIZE=+0>Для двунаправленной пересылки данных применяют команду <B><A HREF="../../Text/Command.htm#xchg" TARGET="M3">xchg</A></B>.
Для этой операции можно, конечно, применить последовательность из нескольких
команд <I>mov</I>, но из-за того, что операция обмена используется довольно
часто, разработчики системы команд микропроцессора посчитали нужным ввести
отдельную команду обмена xchg. Естественно, что операнды должны иметь один
тип. Не допускается (как и для всех команд ассемблера) обменивать между
собой содержимое двух ячеек памяти. К примеру,</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xchg&nbsp;&nbsp;&nbsp; ax,bx&nbsp;&nbsp; ;обменять содержимое регистров ax и bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xchg&nbsp;&nbsp;&nbsp; ax,word ptr [si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;обменять содержимое регистра ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;и слова в памяти по адресу в [si]</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<A NAME="ВводаВыводаВПорт"></A>
<H3>
<FONT SIZE=+0>Команды ввода-вывода в порт</FONT></H3>
<FONT SIZE=+0>На уроке 6 при обсуждении вопроса о том, <I><A HREF="../Lesson06/Les_06.htm#ГдеОперанды" TARGET="M3">где
могут находиться операнды машинной команды</A></I>, мы упоминали <B>порт
ввода- вывода</B>.</FONT>
<BR><FONT SIZE=+0>Посмотрите на <B>рис. 1</B>. На нем показана сильно упрощенная,
концептуальная схема управления оборудованием компьютера.</FONT>
<CENTER></CENTER>

<P><CENTER><IMG SRC="Ris7_01.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<CENTER></CENTER>

<CENTER><I><FONT SIZE=+0><B>Рис. 1. </B>Концептуальная схема управления
оборудованием компьютера</FONT></I></CENTER>


<P><FONT SIZE=+0>Как видно из рис. 1, самым нижним уровнем является уровень
BIOS, на котором работа с оборудованием ведется напрямую через порты. Тем
самым реализуется концепция независимости от оборудования. При замене оборудования
необходимо будет лишь подправить соответствующие функции BIOS, переориентировав
их на новые адреса и логику работы портов.</FONT>

<P><FONT SIZE=+0>Принципиально управлять устройствами напрямую через порты
несложно. Сведения о номерах портов, их разрядности, формате управляющей
информации приводятся в техническом описании устройства. Необходимо знать
лишь конечную цель своих действий, алгоритм, в соответствии с которым работает
конкретное устройство, и порядок программирования его портов. То есть,
фактически, нужно знать, что и в какой последовательности нужно послать
в порт (при записи в него) или считать из него (при чтении) и как следует
трактовать эту информацию. Для этого достаточно всего двух команд, присутствующих
в системе команд микропроцессора:</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#in" TARGET="M3">in</A>
аккумулятор,номер_порта</FONT></B><FONT SIZE=+0> — ввод в аккумулятор из
порта с номером номер_порта;</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#out" TARGET="M3">out</A>
порт,аккумулятор</FONT></B><FONT SIZE=+0> — вывод содержимого аккумулятора
в порт с номером номер_порта.&nbsp;</FONT><A NAME="РаботыСАдресамиИУказателями"></A>
<H4>
<FONT SIZE=+0>Команды работы с адресами и указателями памяти</FONT></H4>
<FONT SIZE=+0>При написании программ на ассемблере производится интенсивная
работа с адресами операндов, находящимися в памяти. Для поддержки такого
рода операций есть специальная группа команд, в которую входят следующие
команды:</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#lea" TARGET="M3">lea</A>
назначение,источник</FONT></B><FONT SIZE=+0> — загрузка эффективного адреса;</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#lds" TARGET="M3">lds</A>
назначение,источник</FONT></B><FONT SIZE=+0> — загрузка указателя в регистр
сегмента данных ds;</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#lds" TARGET="M3">les</A>
назначение,источник</FONT></B><FONT SIZE=+0> — загрузка указателя в регистр
дополнительного сегмента данных es;</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#lds" TARGET="M3">lgs</A>
назначение,источник</FONT></B><FONT SIZE=+0> — загрузка указателя в регистр
дополнительного сегмента данных gs;</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#lds" TARGET="M3">lfs</A>
назначение,источник</FONT></B><FONT SIZE=+0> — загрузка указателя в регистр
дополнительного сегмента данных fs;</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#lds" TARGET="M3">lss</A>
назначение,источник</FONT></B><FONT SIZE=+0> — загрузка указателя в регистр
сегмента стека ss.</FONT>

<P><FONT SIZE=+0>Команда <I>lea</I> похожа на команду <I>mov</I> тем, что
она также производит пересылку. Однако, обратите внимание, команда <I>lea</I>
производит пересылку не данных, а эффективного адреса данных (то есть смещения
данных относительно начала сегмента данных) в регистр, указанный операндом
назначение.</FONT>

<P><FONT SIZE=+0>Часто для выполнения некоторых действий в программе недостаточно
знать значение одного лишь эффективного адреса данных, а необходимо иметь
полный указатель на данные. Вы помните, что полный указатель на данные
состоит из сегментной составляющей и смещения.</FONT>
<BR><FONT SIZE=+0>Все остальные команды этой группы позволяют получить
в паре регистров такой полный указатель на операнд в памяти. При этом <I>имя
сегментного регистра</I>, в который помещается сегментная составляющая
адреса, определяется кодом операции. Соответственно, <I>смещение</I> помещается
в регистр общего назначения, указанный операндом <I>назначение</I>.</FONT>
<BR><FONT SIZE=+0>Но не все так просто с операндом <I>источник</I>. На
самом деле, в команде в качестве источника нельзя указывать непосредственно
имя операнда в памяти, на который мы бы хотели получить указатель.</FONT>
<BR><FONT SIZE=+0>Предварительно необходимо получить само значение полного
указателя в некоторой области памяти и указать в команде получения полного
адреса имя этой области. Для выполнения этого действия необходимо вспомнить
директивы резервирования и инициализации памяти.</FONT>
<BR><FONT SIZE=+0>При применении этих директив возможен частный случай,
когда в поле операндов указывается имя другой директивы определения данных
(фактически, имя переменной). В этом случае в памяти формируется адрес
этой переменной. Какой адрес будет сформирован (эффективный или полный),
зависит от применяемой директивы. Если это dw, то в памяти формируется
только 16-битное значение эффективного адреса, если же dd — в память записывается
полный адрес. Размещение этого адреса в памяти следующее: в младшем слове
находится смещение, в старшем — 16-битная сегментная составляющая адреса.</FONT>

<P><FONT SIZE=+0>Например, при организации работы с цепочкой символов удобно
поместить ее начальный адрес в некоторый регистр и далее в цикле модифицировать
это значение для последовательного доступа к элементам цепочки. В <B>листинге
1</B> производится копирование строки байт <I>str_1</I> в строку байт <I>str_2</I>.</FONT>
<BR><FONT SIZE=+0>В строках 12 и 13 в регистры si и di загружаются значения
эффективных адресов переменных str_1 и str_2.</FONT>
<BR><FONT SIZE=+0>В строках 16 и 17 производится пересылка очередного байта
из одной строки в другую. Указатели на позиции байтов в строках определяются
содержимым регистров si и di. Для пересылки очередного байта необходимо
увеличить на единицу регистры si и di, что и делается командами сложения
inc (строки 18, 19). После этого программу необходимо зациклить до обработки
всех символов строки.&nbsp;</FONT><A NAME="Листинг_1"></A>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
Листинг 1. Копирование строки
&lt;1>;---------Prg_7_2.asm---------------
&lt;2>&nbsp;&nbsp;&nbsp;&nbsp; masm
&lt;3>&nbsp;&nbsp;&nbsp;&nbsp; model&nbsp;&nbsp; small
&lt;4>&nbsp;&nbsp;&nbsp;&nbsp; .data
&lt;5>&nbsp;&nbsp;&nbsp;&nbsp; ...
&lt;6>&nbsp;&nbsp;&nbsp;&nbsp; str_1 db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘Ассемблер — базовый язык компьютера’
&lt;7>&nbsp;&nbsp;&nbsp;&nbsp; str_2&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50 dup (‘ ‘)
&lt;8>&nbsp;&nbsp;&nbsp;&nbsp; full_pnt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd str_1
&lt;9>&nbsp;&nbsp;&nbsp;&nbsp; ...
&lt;10>&nbsp;&nbsp;&nbsp; .code
&lt;11>&nbsp;&nbsp;&nbsp; start:
&lt;12>&nbsp;&nbsp;&nbsp; ...
&lt;13>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,str_1
&lt;14>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,str_2
&lt;15>&nbsp;&nbsp;&nbsp; les&nbsp;&nbsp;&nbsp;&nbsp; bx,full_pnt&nbsp;&nbsp;&nbsp;&nbsp; ;полный указатель на str1 в пару es:bx
&lt;16>&nbsp;&nbsp;&nbsp; m1:
&lt;17>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,[si]
&lt;18>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [di],al
&lt;19>&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; si
&lt;20>&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; di
&lt;21> ;цикл на метку m1 до пересылки всех символов
&lt;22> ...
&lt;23>&nbsp;&nbsp;&nbsp; end&nbsp;&nbsp;&nbsp;&nbsp; start</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Необходимость использования команд получения полного указателя
данных в памяти, то есть адреса сегмента и значения смещения внутри сегмента,
возникает, в частности, при работе с цепочками.</FONT>
<BR><FONT SIZE=+0>В строке 14 листинга 1 в двойном слове full_pnt формируются
сегментная часть адреса и смещение для переменной str_1. При этом 2 байта
смещения занимают младшее слово full_pnt, а значение сегментной составляющей
адреса — старшее слово full_pnt. В строке 14 командой les эти компоненты
адреса помещаются в регистры bx и es.&nbsp;</FONT><A NAME="ПреобразованияДанных"></A>
<H4>
<FONT SIZE=+0>Команды преобразования данных</FONT></H4>
<FONT SIZE=+0>К этой группе можно отнести множество команд микропроцессора,
но большинство из них имеют те или иные особенности, которые требуют отнести
их к другим функциональным группам.</FONT>
<BR><FONT SIZE=+0>Поэтому из всей совокупности команд микропроцессора непосредственно
к командам преобразования данных можно отнести только одну команду:</FONT>
<BR><B><FONT SIZE=+0><A HREF="../../Text/Command.htm#xlatb" TARGET="M3">xlat</A>
[адрес_таблицы_перекодировки]</FONT></B><FONT SIZE=+0></FONT>

<P><FONT SIZE=+0>Это очень интересная и полезная команда. Ее действие заключается
в том, что она замещает значение в регистре al другим байтом из таблицы
в памяти, расположенной по адресу, указанному операндом адрес_таблицы_перекодировки.</FONT>
<BR><FONT SIZE=+0>Слово “таблица” весьма условно — по сути это просто строка
байт. Адрес байта в строке, которым будет производиться замещение содержимого
регистра al, определяется суммой (bx) + (al), то есть содержимое al выполняет
роль индекса в байтовом массиве.</FONT>

<P><FONT SIZE=+0>При работе с командой xlat обратите внимание на следующий
тонкий момент. Несмотря на то, что в команде указывается адрес строки байт,
из которой должно быть извлечено новое значение, этот адрес должен быть
предварительно загружен (например, с помощью команды <I>lea</I>) в регистр
bx. Таким образом, операнд адрес_таблицы_перекодировки на самом деле не
нужен (необязательность операнда показана заключением его в квадратные
скобки). Что касается строки байт (таблицы перекодировки), то она представляет
собой область памяти размером от 1 до 255 байт (диапазон числа без знака
в 8-битном регистре).</FONT>

<P><FONT SIZE=+0>В качестве иллюстрации работы данной команды мы рассмотрим
программу, которая преобразует двузначное шестнадцатеричное число, вводимое
с клавиатуры (то есть в символьном виде), в эквивалентное двоичное представление
в регистре al. Ниже (листинг 2) приведен вариант этой программы с использованием
команды xlat.&nbsp;</FONT><A NAME="Листинг_2"></A>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
Листинг 2. Использование таблицы перекодировки
&lt;1>;---------Prg_7_3.asm----------------------
&lt;2>;Программа преобразования двузначного шестнадцатеричного числа
&lt;3>;в двоичное представление с использованием команды xlat.
&lt;4>;Вход: исходное шестнадцатеричное число; вводится с клавиатуры.
&lt;5>;Выход: результат преобразования в регистре al.
&lt;6>.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент данных
&lt;7>&nbsp; message&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘Введите две шестнадцатеричные цифры,$’
&lt;8>&nbsp; tabl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 dup (0),0,1,2,3,4,5,6,7,8,9, 8 dup (0),
&lt;9>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0bh,0ch,odh,0eh,0fh,27 dup (0)
&lt;10>&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0bh,0ch,odh,0eh,0fh, 153 dup (0)
&lt;11> .stack&nbsp;&nbsp;&nbsp;&nbsp; 256&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент стека
&lt;12> .code
&lt;13> ;начало сегмента кода
&lt;14> proc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp; ;начало процедуры main
&lt;15>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;физический адрес сегмента данных в регистр ax
&lt;16>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax&nbsp;&nbsp; ;ax записываем в ds
&lt;17>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; bx,tabl ;загрузка адреса строки байт в регистр bx
&lt;18>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,9
&lt;19>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,offset message
&lt;20>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывести приглашение к вводу
&lt;21>&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; ax,ax&nbsp;&nbsp; ;очистить регистр ax
&lt;22>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,1h&nbsp;&nbsp; ;значение 1h в регистр ah
&lt;23>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вводим первую цифру в al
&lt;24>&nbsp;&nbsp;&nbsp; xlat&nbsp;&nbsp;&nbsp; ;перекодировка первого введенного символа в al
&lt;25>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dl,al
&lt;26>&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp; dl,4&nbsp;&nbsp;&nbsp; ;сдвиг dl влево для освобождения места для младшей цифры
&lt;27>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;ввод второго символа в al
&lt;28>&nbsp;&nbsp;&nbsp; xlat&nbsp;&nbsp;&nbsp; ;перекодировка второго введенного символа в al
&lt;29>&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; al,dl&nbsp;&nbsp; ;складываем для получения результата
&lt;30>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;пересылка 4c00h в регистр ax
&lt;31>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;завершение программы
&lt;32> endp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp; ;конец процедуры main
&lt;33> code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ends&nbsp;&nbsp;&nbsp; ;конец сегмента кода
&lt;34> endmain&nbsp;&nbsp;&nbsp; ;конец программы с точкой входа main</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Сама по себе программа проста; сложность вызывает обычно
формирование таблицы перекодировки. Обсудим этот момент подробнее.</FONT>
<BR><FONT SIZE=+0>Прежде всего нужно определиться с значениями тех байтов,
которые вы будете изменять. В нашем случае это символы шестнадцатеричных
цифр. Сконструируем в сегменте данных таблицу, в которой на места байтов,
соответствующих символам шестнадцатеричных цифр, помещаем их новые значения,
то есть двоичные эквиваленты шестнадцатеричных цифр. Строки 8-10 листинга
2 демонстрируют, как это сделать. Байты этой таблицы, смещения которых
не совпадают со значением кодов шестнадцатеричных цифр, нулевые. Таковыми
являются первые 48 байт таблицы, промежуточные байты и часть в конце таблицы.</FONT>
<BR><FONT SIZE=+0>Желательно определить все 256 байт таблицы. Дело в том,
что если мы ошибочно поместим в al код символа, отличный от символа шестнадцатеричной
цифры, то после выполнения команды xlat получим непредсказуемый результат.
В случае листинга 2 это будет ноль, что не совсем корректно, так как непонятно,
что же в действительности было в al — код символа “0” или что-то другое.</FONT>
<BR><FONT SIZE=+0>Поэтому, наверное, есть смысл здесь поставить “защиту
от дурака”, поместив в неиспользуемые байты таблицы какой-нибудь определенный
символ. После каждого выполнения xlat нужно будет просто контролировать
значение в al на предмет совпадения с этим символом, и если оно произошло,
выдавать сообщение об ошибке.</FONT>
<BR><FONT SIZE=+0>После того как таблица составлена, с ней можно работать.
В сегменте команд строка 18 инициализирует регистр bx значением адреса
таблицы tabl. Далее все очень просто. Поочередно вводятся символы двух
шестнадцатеричных цифр, и производится их перекодировка в соответствующие
двоичные эквиваленты.&nbsp;</FONT><A NAME="РаботыСоСтеком"></A>
<H4>
<FONT SIZE=+0>Команды работы со стеком</FONT></H4>
<FONT SIZE=+0>Эта группа представляет собой набор специализированных команд,
ориентированных на организацию гибкой и эффективной работы со стеком.</FONT>

<P><FONT SIZE=+0><B><I>Стек</I></B> — это область памяти, специально выделяемая
для временного хранения данных программы. Важность стека определяется тем,
что для него в структуре программы предусмотрен отдельный сегмент. На тот
случай, если программист забыл описать сегмент стека в своей программе,
компоновщик tlink выдаст предупреждающее сообщение.</FONT>

<P><FONT SIZE=+0>Для работы со стеком предназначены три регистра:</FONT>
<UL>
<LI>
<FONT SIZE=+0><B>ss</B> — сегментный регистр стека;</FONT></LI>

<LI>
<FONT SIZE=+0><B>sp/esp</B> — регистр указателя стека;</FONT></LI>

<LI>
<FONT SIZE=+0><B>bp/ebp</B> — регистр указателя базы кадра стека.</FONT></LI>
</UL>
<FONT SIZE=+0>Размер стека зависит от режима работы микропроцессора и ограничивается
64 Кбайт (или 4 Гбайт в защищенном режиме).</FONT>
<BR><FONT SIZE=+0>В каждый момент времени доступен только один стек, адрес
сегмента которого содержится в регистре ss. Этот стек называется <I>текущим</I>.
Для того чтобы обратиться к другому стеку (“переключить стек”), необходимо
загрузить в регистр ss другой адрес. Регистр ss автоматически используется
процессором для выполнения всех команд, работающих со стеком.</FONT>

<P><FONT SIZE=+0>Перечислим еще некоторые особенности работы со стеком:</FONT>
<UL>
<LI>
<FONT SIZE=+0>запись и чтение данных в стеке осуществляется в соответствии
с принципом LIFO (Last In First Out — “последним пришел, первым ушел”);</FONT></LI>

<LI>
<FONT SIZE=+0>по мере записи данных в стек последний растет в сторону младших
адресов. Эта особенность заложена в алгоритм команд работы со стеком;</FONT></LI>

<LI>
<FONT SIZE=+0>при использовании регистров esp/sp и ebp/bp для адресации
памяти ассемблер автоматически считает, что содержащиеся в нем значения
представляют собой смещения относительно сегментного регистра ss.</FONT></LI>
</UL>
<FONT SIZE=+0>В общем случае стек организован так, как показано на рис.
2.</FONT>
<CENTER></CENTER>

<P><CENTER><IMG SRC="Ris7_03.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<CENTER></CENTER>

<CENTER><I><FONT SIZE=+0><B>Рис. 2. </B>Концептуальная схема организации
стека</FONT></I></CENTER>


<P><FONT SIZE=+0>Для работы со стеком предназначены регистры <I>ss, esp/sp
и ebp/bp</I>.</FONT>
<BR><FONT SIZE=+0>Эти регистры используются комплексно, и каждый из них
имеет свое функциональное назначение.</FONT>
<BR><FONT SIZE=+0>Регистр esp/sp всегда указывает на вершину стека, то
есть содержит смещение, по которому в стек был занесен последний элемент.
Команды работы со стеком неявно изменяют этот регистр так, чтобы он указывал
всегда на последний записанный в стек элемент. Если стек пуст, то значение
esp равно адресу последнего байта сегмента, выделенного под стек.</FONT>
<BR><FONT SIZE=+0>При занесении элемента в стек процессор уменьшает значение
регистра esp, а затем записывает элемент по адресу новой вершины.</FONT>
<BR><FONT SIZE=+0>При извлечении данных из стека процессор копирует элемент,
расположенный по адресу вершины, а затем увеличивает значение регистра
указателя стека esp.</FONT>
<BR><FONT SIZE=+0>Таким образом, получается, что стек растет вниз, в сторону
уменьшения адресов.</FONT>

<P><FONT SIZE=+0>Что делать, если нам необходимо получить доступ к элементам
не на вершине, а внутри стека?</FONT>
<BR><FONT SIZE=+0>Для этого применяют регистр ebp. Регистр <B>ebp</B> —
<I>регистр указателя базы кадра стека</I>.</FONT>
<BR><FONT SIZE=+0>Например, типичным приемом при входе в подпрограмму является
передача нужных параметров путем записи их в стек. Если подпрограмма тоже
активно работает со стеком, то доступ к этим параметрам становится проблематичным.
Выход в том, чтобы после записи нужных данных в стек сохранить адрес вершины
стека в указателе кадра (базы) стека — регистре ebp. Значение в ebp в дальнейшем
можно использовать для доступа к переданным параметрам.</FONT>

<P><FONT SIZE=+0>Начало стека расположено в старших адресах памяти. На
рис. 2 этот адрес обозначен парой ss:ffff. Смещение ffff приведено здесь
условно. Реально это значение определяется величиной, которую программист
задает при описании сегмента стека в своей программе.</FONT>
<BR><FONT SIZE=+0>К примеру, для программы в <A HREF="#Листинг_2">листинге
2</A> началу стека будет соответствовать пара ss:0100h. Адресная пара ss:ffff
— это максимальное для реального режима значение адреса начала стека, так
как размер сегмента в нем ограничен величиной 64 Кбайт (0ffffh).</FONT>

<P><FONT SIZE=+0>Для организации работы со стеком существуют специальные
команды записи и чтения.</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#push" TARGET="M3">push</A></B>
<B>источник</B> — запись значения источник в вершину стека.</FONT>
<BR><FONT SIZE=+0>Интерес представляет алгоритм работы этой команды, который
включает следующие действия (рис. 3):</FONT>
<UL>
<LI>
<FONT SIZE=+0>(sp) = (sp) – 2; значение sp уменьшается на 2;</FONT></LI>

<LI>
<FONT SIZE=+0>значение из источника записывается по адресу, указываемому
парой ss:sp.</FONT></LI>
</UL>

<P><CENTER><IMG SRC="Ris7_04.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<CENTER></CENTER>

<CENTER><I><FONT SIZE=+0><B>Рис. 3. </B>Принцип работы команды push</FONT></I></CENTER>


<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#pop" TARGET="M3">pop</A></B>
<B>назначение</B> — запись значения из вершины стека по месту, указанному
операндом назначение. Значение при этом “снимается” с вершины стека.</FONT>
<BR><FONT SIZE=+0>Алгоритм работы команды pop обратен алгоритму команды
push (рис. 4):</FONT>
<UL>
<LI>
<FONT SIZE=+0>запись содержимого вершины стека по месту, указанному операндом
назначение;</FONT></LI>

<LI>
<FONT SIZE=+0>(sp) = (sp) + 2; увеличение значения sp.</FONT></LI>
</UL>

<P><CENTER><IMG SRC="Ris7_05.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<CENTER></CENTER>

<CENTER><I><FONT SIZE=+0><B>Рис. 4. </B>Принцип работы команды pop</FONT></I></CENTER>


<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#pusha" TARGET="M3">pusha</A></B>
— команда групповой записи в стек.</FONT>
<BR><FONT SIZE=+0>По этой команде в стек последовательно записываются регистры
ax, cx, dx, bx, sp, bp, si, di. Заметим, что записывается оригинальное
содержимое sp, то есть то, которое было до выдачи команды pusha (рис. 5).</FONT>
<CENTER></CENTER>

<P><CENTER><IMG SRC="Ris7_06.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<CENTER></CENTER>

<CENTER><I><FONT SIZE=+0><B>Рис. 5. </B>Принцип работы команды pusha</FONT></I></CENTER>


<P><FONT SIZE=+0><B>pushaw</B> — почти синоним команды pusha. В чем разница?
На уроке 5 мы обсуждали один из атрибутов сегмента — атрибут разрядности.
Он может принимать значение use16 или use32.</FONT>
<BR><FONT SIZE=+0>Рассмотрим работу команд pusha и pushaw при каждом из
этих атрибутов:</FONT>
<UL>
<LI>
<FONT SIZE=+0>use16 — алгоритм работы pushaw аналогичен алгоритму pusha.</FONT></LI>

<LI>
<FONT SIZE=+0>use32 — pushaw не изменяется (то есть она нечувствительна
к разрядности сегмента и всегда работает с регистрами размером в слово
— ax, cx, dx, bx, sp, bp, si, di). Команда pusha чувствительна к установленной
разрядности сегмента и при указании 32-разрядного сегмента работает с соответствующими
32-разрядными регистрами, то есть eax, ecx, edx, ebx, esp, ebp, esi, edi.</FONT></LI>
</UL>


<P><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#pushad" TARGET="M3">pushad</A></B>
— выполняется аналогично команде pusha, но есть некоторые особенности,
которые вы можете узнать из “Справочника команд”.</FONT>

<P><FONT SIZE=+0>Следующие три команды выполняют действия, обратные вышеописанным
командам:</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#popa" TARGET="M3">popa</A></B>;</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#popaw" TARGET="M3">popaw</A></B>;</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#popad" TARGET="M3">popad</A></B>.</FONT>

<P><FONT SIZE=+0>Группа команд, описанная ниже, позволяет сохранить в стеке
регистр флагов и записать слово или двойное слово в стеке. Отметим, что
перечисленные ниже команды — единственные в системе команд микропроцессора,
которые позволяют получить доступ (и которые нуждаются в этом доступе)
ко всему содержимому регистра флагов.</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#pushf" TARGET="M3">pushf</A></B>
— сохраняет регистр флагов в стеке.</FONT>
<BR><FONT SIZE=+0>Работа этой команды зависит от атрибута размера сегмента:</FONT>
<UL>
<LI>
<FONT SIZE=+0>use16 — в стек записывается регистр flags размером 2 байта;</FONT></LI>

<LI>
<FONT SIZE=+0>use32 — в стек записывается регистр eflags размером 4 байта.</FONT></LI>
</UL>


<P><FONT SIZE=+0><B>pushfw</B> — сохранение в стеке регистра флагов размером
в слово. Всегда работает как pushf с атрибутом use16.</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#pushfd" TARGET="M3">pushfd</A></B>
— сохранение в стеке регистра флагов flags или eflags в зависимости от
атрибута разрядности сегмента (то есть то же, что и pushf).</FONT>

<P><FONT SIZE=+0>Аналогично, следующие три команды выполняют действия,
обратные рассмотренным выше операциям:</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#popf" TARGET="M3">popf</A></B></FONT>
<BR><FONT SIZE=+0><B>popfw</B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#popfd" TARGET="M3">popfd</A></B></FONT>

<P><FONT SIZE=+0>И в заключение отметим основные виды операции, когда использование
стека практически неизбежно:</FONT>
<UL>
<LI>
<FONT SIZE=+0>вызов подпрограмм;</FONT></LI>

<LI>
<FONT SIZE=+0>временное сохранение значений регистров;</FONT></LI>

<LI>
<FONT SIZE=+0>определение локальных переменных.</FONT></LI>
</UL>
<!C-HR SIZE=5 WIDTH=80%>
</BODY>
<!конец html-документа>
</HTML>
