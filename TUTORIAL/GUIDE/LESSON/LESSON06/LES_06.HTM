<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE>Из урока 6</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF">
<!базовый размер символов (для всего документа><!тело html-документа><A NAME="ЦелочисленныеАрифметическиеКоманды"></A>
<HR SIZE=5 WIDTH=60%><A NAME="ФорматМашиннойКоманды"></A>
<H3>
<FONT SIZE=+0>Структура машинной команды</FONT></H3>
<FONT SIZE=+0>Машинная команда представляет собой закодированное по определенным
правилам указание микропроцессору на выполнение некоторой операции или
действия. Каждая команда содержит элементы, определяющие:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>что делать?</I> (ответ на этот вопрос дает элемент команды,
называемый кодом операции (КОП));</FONT></LI>

<LI>
<FONT SIZE=+0><I>объекты, над которыми</I> нужно что-то делать (эти элементы
называются операндами);</FONT></LI>

<LI>
<FONT SIZE=+0><I>как делать?</I> (эти элементы называются типами операндов
— обычно задаются неявно).</FONT></LI>
</UL>
<FONT SIZE=+0>Приведенный на рис. 1 формат машинной команды является самым
общим. Максимальная длина машинной команды — 15 байт. Реальная команда
может содержать гораздо меньшее количество полей, вплоть до одного — только
КОП.&nbsp;<A NAME="Рис_1"></A></FONT>
<P><CENTER><IMG SRC="Ris6_05.gif" BORDER=0 ></CENTER>

<CENTER><I><FONT SIZE=+0><B>Рис. 1. </B>Формат машинной команды</FONT></I></CENTER>


<P><FONT SIZE=+0>Опишем назначения полей машинной команды.</FONT>
<UL>
<LI>
<FONT SIZE=+0><B>Префиксы</B>. Необязательные элементы машинной команды,
каждый из которых состоит из одного байта или может отсутствовать. В памяти
префиксы предшествуют команде. Назначение префиксов — модифицировать операцию,
выполняемую командой. Прикладная программа может использовать следующие
типы префиксов:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0><I>Префикс замены сегмента</I>. В явной форме указывает,
какой сегментный регистр используется в данной команде для адресации стека
или данных. Префикс отменяет выбор сегментного регистра по умолчанию. Префиксы
замены сегмента имеют следующие значения:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>2eh — замена сегмента cs;</FONT></LI>

<LI>
<FONT SIZE=+0>36h — замена сегмента ss;</FONT></LI>

<LI>
<FONT SIZE=+0>3eh — замена сегмента ds;</FONT></LI>

<LI>
<FONT SIZE=+0>26h — замена сегмента es;</FONT></LI>

<LI>
<FONT SIZE=+0>64h — замена сегмента fs;</FONT></LI>

<LI>
<FONT SIZE=+0>65h — замена сегмента gs.</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0><I>Префикс разрядности адреса</I> уточняет разрядность адреса
(32 или 16-разрядный).</FONT></LI>

<BR><FONT SIZE=+0>Каждой команде, в которой используется адресный операнд,
ставится в соответствие разрядность адреса этого операнда. Этот адрес может
иметь разрядность 16 или 32 бит. Если разрядность адреса для данной команды
16 бит, это означает, что команда содержит 16-разрядное смещение (см. <I><A HREF="#Рис_1">рис.
1</A></I>), оно соответствует 16-разрядному смещению адресного операнда
относительно начала некоторого сегмента. В контексте <I><A HREF="#Рис_2">рис.
2</A></I> это смещение называется эффективный адрес. Если разрядность адреса
32 бит, это означает, что команда содержит 32-разрядное смещение (см. <I><A HREF="#Рис_1">рис.
1</A></I> ), оно соответствует 32-разрядному смещению адресного операнда
относительно начала сегмента и по его значению формируется 32-битное смещение
в сегменте. С помощью префикса разрядности адреса можно изменить действующее
по умолчанию значение разрядности адреса. Это изменение будет касаться
только той команды, которой предшествует префикс.&nbsp;<A NAME="Рис_2"></A></FONT>
<P><CENTER><IMG SRC="Ris2_3.gif" BORDER=0 ></CENTER>

<CENTER><I><FONT SIZE=+0><B>Рис. 2. </B>Механизм формирования физического
адреса в реальном режиме</FONT></I></CENTER>

<LI>
<FONT SIZE=+0><I>Префикс разрядности операнда</I> аналогичен префиксу разрядности
адреса, но указывает на разрядность операндов (32 или 16-разрядные), с
которыми работает команда. В соответствии с какими правилами устанавливаются
значения атрибутов разрядности адреса и операндов по умолчанию?</FONT></LI>

<BR><FONT SIZE=+0>В реальном режиме и режиме виртуального i8086 значения
этих атрибутов — 16 бит.</FONT>
<BR><FONT SIZE=+0>В защищенном режиме значения атрибутов зависят от состояния
бита <I>D</I> в дескрипторах исполняемых сегментов (см. урок 16). Если
<I>D</I> = 0, то значения атрибутов, действующие по умолчанию, равны 16
бит; если <I>D</I> = 1, то 32 бит.</FONT>
<BR><FONT SIZE=+0>Значения префиксов разрядности операнда <B>66h</B> и
разрядности адреса <B>67h</B>. Вы можете с помощью префикса разрядности
адреса в реальном режиме использовать 32-разрядную адресацию, но при этом
необходимо помнить об ограниченности размера сегмента величиной 64 Кбайт.
Аналогично префиксу разрядности адреса вы можете использовать префикс разрядности
операнда в реальном режиме для работы с 32-разрядными операндами (к примеру,
в арифметических командах).</FONT>
<LI>
<FONT SIZE=+0><I>Префикс повторения</I> используется с цепочечными командами
(командами обработки строк). Этот префикс “зацикливает” команду для обработки
всех элементов цепочки. Система команд поддерживает два типа префиксов:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0><I>безусловные</I> (rep — 0f3h), заставляющие повторяться
цепочечную команду некоторое количество раз;</FONT></LI>

<LI>
<FONT SIZE=+0><I>условные</I> (repe/repz — 0f3h, repne/repnz — 0f2h), которые
при зацикливании проверяют некоторые флаги, и в результате проверки возможен
досрочный выход из цикла.</FONT></LI>
</UL>
</UL>

<LI>
<FONT SIZE=+0><B>Код операции</B>. Обязательный элемент, описывающий операцию,
выполняемую командой. Многим командам соответствует несколько кодов операций,
каждый из которых определяет нюансы выполнения операции.</FONT></LI>


<P><FONT SIZE=+0>Последующие поля машинной команды определяют местоположение
операндов, участвующих в операции, и особенности их использования. Рассмотрение
этих полей связано со способами задания операндов в машинной команде и
потому будет выполнено позже.</FONT>
<LI>
<B><FONT SIZE=+0>Байт режима адресации <I>modr/m</I></FONT></B><FONT SIZE=+0>.
Значения этого байта определяет используемую форму адреса операндов. Операнды
могут находиться в памяти в одном или двух регистрах. Если операнд находится
в памяти, то байт <I>modr/m</I> определяет компоненты (смещение, базовый
и индексный регистры), используемые для вычисления его эффективного адреса
(см. <I><A HREF="#Рис_2">рис. 2</A></I>). В защищенном режиме для определения
местоположения операнда в памяти может дополнительно использоваться байт
<I>sib</I> (Scale-Index-Base — масштаб-индекс-база). Байт <I>modr/m</I>
состоит из трех полей (см. <I><A HREF="#Рис_1">рис. 1</A></I>):</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>поле <I>mod</I> определяет количество байт, занимаемых в
команде адресом операнда (см. <I><A HREF="#Рис_1">рис. 1</A></I>, поле
<I>смещение в команде</I>).</FONT></LI>

<BR><FONT SIZE=+0>Поле <I>mod</I> используется совместно с полем <I>r/m</I>,
которое указывает способ модификации адреса операнда смещение в команде.</FONT>
<BR><FONT SIZE=+0>К примеру, если <I>mod</I> = 00, это означает, что поле
<I>смещение в команде</I> отсутствует, и адрес операнда определяется содержимым
базового и (или) индексного регистра. Какие именно регистры будут использоваться
для вычисления эффективного адреса, определяется значением этого байта.</FONT>
<BR><FONT SIZE=+0>Если <I>mod</I> = 01, это означает, что поле <I>смещение
в команде</I> присутствует, занимает один байт и модифицируется содержимым
базового и (или) индексного регистра.</FONT>
<BR><FONT SIZE=+0>Если <I>mod</I> = 10, это означает, что поле <I>смещение
в команде</I> присутствует, занимает два или четыре байта (в зависимости
от действующего по умолчанию или определяемого префиксом размера адреса)
и модифицируется содержимым базового и (или) индексного регистра.</FONT>
<BR><FONT SIZE=+0>Если <I>mod</I> = 11, это означает, что операндов в памяти
нет: они находятся в регистрах. Это же значение байта <I>mod</I> используется
в случае, когда в команде применяется непосредственный операнд;</FONT>
<LI>
<FONT SIZE=+0>поле <I>reg/коп</I> определяет либо регистр, находящийся
в команде на месте первого операнда, либо возможное расширение кода операции;</FONT></LI>

<LI>
<FONT SIZE=+0>поле <I>r/m</I> используется совместно с полем <I>mod</I>
и определяет либо регистр, находящийся в команде на месте первого операнда
(если <I>mod</I> = 11), либо используемые для вычисления эффективного адреса
(совместно с полем смещение в команде) базовые и индексные регистры.</FONT></LI>
</UL>

<LI>
<B><FONT SIZE=+0>Байт масштаб-индекс-база (байт <I>sib</I>)</FONT></B><FONT SIZE=+0>
используется для расширения возможностей адресации операндов.</FONT></LI>

<BR><FONT SIZE=+0>На наличие байта <I>sib</I> в машинной команде указывает
сочетание одного из значений 01 или 10 поля <I>mod</I> и значения поля
<I>r/m</I>= 100. Байт <I>sib</I> состоит из трех полей:</FONT>
<UL>
<LI>
<I><FONT SIZE=+0>поля масштаба <B>ss</B></FONT></I><FONT SIZE=+0>. В этом
поле размещается масштабный множитель для индексного компонента <I>index</I>,
занимающего следующие три бита байта <I>sib</I>.</FONT></LI>

<BR><FONT SIZE=+0>В поле <I>ss</I> может содержаться одно из следующих
значений: 1, 2, 4, 8.</FONT>
<BR><FONT SIZE=+0>При вычислении эффективного адреса на это значение будет
умножаться содержимое индексного регистра. Более подробно с практической
точки зрения эта расширенная возможность индексации рассматривается на
уроке 12 при обсуждении вопросов работы с массивами;</FONT>
<LI>
<I><FONT SIZE=+0>поля <B>index</B></FONT></I><FONT SIZE=+0> — используется
для хранения номера индексного регистра, который применяется для вычисления
эффективного адреса операнда;</FONT></LI>

<LI>
<I><FONT SIZE=+0>поля <B>base —</B></FONT></I><FONT SIZE=+0> используется
для хранения номера базового регистра, который также применяется для вычисления
эффективного адреса операнда. Напомню, что в качестве базового и индексного
регистров могут использоваться практически все регистры общего назначения.</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0><B>Поле смещения в команде</B>. 8, 16 или 32-разрядное целое
число со знаком, представляющее собой, полностью или частично (с учетом
вышеприведенных рассуждений), значение эффективного адреса операнда.</FONT></LI>

<LI>
<FONT SIZE=+0><B>Поле непосредственного операнда</B>. Необязательное поле,
представляющее собой 8, 16 или 32-разрядный непосредственный операнд. Наличие
этого поля, конечно, отражается на значении байта <I>modr/m</I>.</FONT></LI>
</UL>
<A NAME="ГдеОперанды"></A>
<H3>
<FONT SIZE=+0>Способы задания операндов команды</FONT></H3>
<FONT SIZE=+0>В ходе предыдущего изложения мы поневоле касались вопроса
о том, где располагаются операнды, с которыми работает машинная команда,
и как это отражается на содержимом ее полей.</FONT>
<BR><FONT SIZE=+0>В этой части занятия мы рассмотрим этот вопрос более
систематизировано и в полном объеме. Это позволит нам уже со следующего
занятия перейти непосредственно к практическим вопросам программирования
на языке ассемблера.</FONT>

<P><FONT SIZE=+0><I>Операнд задается неявно на микропрограммном уровне</I>.
В этом случае команда явно не содержит операндов. Алгоритм выполнения команды
использует некоторые объекты по умолчанию (регистры, флаги в eflags и т.
д.).</FONT>
<BR><FONT SIZE=+0>Например, команды cli и sti неявно работают с флагом
прерывания if в регистре eflags, а команда xlat неявно обращается к регистру
al и строке в памяти по адресу, определяемому парой регистров ds:bx.</FONT>

<P><FONT SIZE=+0><I>Операнд задается в самой команде</I> (непосредственный
операнд). Операнд находится в коде команды, то есть является ее частью.
Для хранения такого операнда в команде выделяется поле длиной до 32 бит
(см. <I><A HREF="#Рис_1">рис. 1</A></I>). Непосредственный операнд может
быть только вторым операндом (источником). Операнд получатель может находиться
либо в памяти, либо в регистре.</FONT>
<BR><FONT SIZE=+0>Например: mov ax,0ffffh пересылает в регистр ax шестнадцатеричную
константу ffff. Команда add sum,2 складывает содержимое поля по адресу
sum с целым числом 2 и записывает результат по месту первого операнда,
то есть в память.</FONT>

<P><FONT SIZE=+0><I>Операнд находится в одном из регистров</I>. Регистровые
операнды указываются именами регистров. В качестве регистров могут использоваться:</FONT>
<UL>
<LI>
<FONT SIZE=+0>32-разрядные регистры EAX, EBX, ECX, EDX, ESI, EDI, ESP,
EBP;</FONT></LI>

<LI>
<FONT SIZE=+0>16-разрядные регистры AX, BX, CX, DX, SI, DI, SP, BP;</FONT></LI>

<LI>
<FONT SIZE=+0>8-разрядные регистры AH, AL, BH, BL, CH, CL, DH, DL;</FONT></LI>

<LI>
<FONT SIZE=+0>сегментные регистры CS, DS, SS, ES, FS, GS.</FONT></LI>
</UL>
<FONT SIZE=+0>Например, команда add ax,bx складывает содержимое регистров
ax и bx и записывает результат в bx. Команда dec si уменьшает содержимое
si на 1.</FONT>

<P><FONT SIZE=+0><I>Операнд располагается в памяти</I>. Это наиболее сложный
и в то жe время наиболее гибкий способ задания операндов. Он позволяет
реализовать следующие два основных вида адресации: <I>прямую</I> и <I>косвенную</I>.</FONT>

<P><FONT SIZE=+0>В свою очередь, <I>косвенная</I> адресация имеет следующие
разновидности:</FONT>
<UL>
<LI>
<FONT SIZE=+0>косвенная базовая адресация; другое ее название — регистровая
косвенная адресация;</FONT></LI>

<LI>
<FONT SIZE=+0>косвенная базовая адресация со смещением;</FONT></LI>

<LI>
<FONT SIZE=+0>косвенная индексная адресация со смещением;</FONT></LI>

<LI>
<FONT SIZE=+0>косвенная базовая индексная адресация;</FONT></LI>

<LI>
<FONT SIZE=+0>косвенная базовая индексная адресация со смещением.</FONT></LI>
</UL>
<FONT SIZE=+0><I>Операндом является порт ввода/вывода</I>. Как мы уже отмечали,
помимо адресного пространства оперативной памяти микропроцессор поддерживает
адресное пространство ввода-вывода, которое используется для доступа к
устройствам ввода-вывода. Объем адресного пространства ввода-вывода составляет
64 Кбайт. Для любого устройства компьютера в этом пространстве выделяются
адреса. Конкретное значение адреса в пределах этого пространства называется
портом ввода-вывода. Физически порту ввода-вывода соответствует аппаратный
регистр (не путать с регистром микропроцессора), доступ к которому осуществляется
с помощью специальных команд ассемблера in и out.</FONT>
<BR><FONT SIZE=+0>Например,</FONT>
<BR><FONT SIZE=+0>in al,60h ;ввести байт из порта 60h</FONT>
<BR><FONT SIZE=+0>Регистры, адресуемые с помощью порта ввода-вывода, могут
иметь разрядность 8, 16 или 32 бит, но для конкретного порта разрядность
регистра фиксирована.</FONT>
<BR><FONT SIZE=+0>Команды <B><A HREF="../../Text/Command.htm#in" TARGET="M3">in</A></B>
и <B><A HREF="../../Text/Command.htm#out" TARGET="M3">out</A></B>
работают с фиксированной номенклатурой объектов. В качестве источника информации
или получателя применяются так называемые регистры-аккумуляторы eax, ax,
al. Выбор регистра определяется разрядностью порта. Номер порта может задаваться
непосредственным операндом в командах in и out или значением в регистре
dx. Последний способ позволяет динамически определить номер порта в программе.
Например:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; dx,20h&nbsp;&nbsp;&nbsp; ;записать номер порта 20h в регистр dx
&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; al,20h&nbsp;&nbsp;&nbsp; ;записать значение 20h в регистр al
&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp; dx,al&nbsp;&nbsp;&nbsp;&nbsp; ;вывести значение 20h в порт 20H</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0><I>Операнд находится в стеке</I>.</FONT>

<P><FONT SIZE=+0>Команды могут совсем не иметь операндов, иметь один или
два операнда. Большинство команд требуют двух операндов, один из которых
является операндом-источником, а второй — операндом назначения. Важно то,
что один операнд может располагаться в регистре или памяти, а второй операнд
обязательно должен находиться в регистре или непосредственно в команде.
Непосредственный операнд может быть только операндом-источником. В двухоперандной
машинной команде возможны следующие сочетания операндов:</FONT>
<UL>
<LI>
<FONT SIZE=+0>регистр—регистр;</FONT></LI>

<LI>
<FONT SIZE=+0>регистр—память;</FONT></LI>

<LI>
<FONT SIZE=+0>память—регистр;</FONT></LI>

<LI>
<FONT SIZE=+0>непосредственный операнд—регистр;</FONT></LI>

<LI>
<FONT SIZE=+0>непосредственный операнд—память.</FONT></LI>
</UL>
<FONT SIZE=+0>У данного правила есть исключения, которые касаются:</FONT>
<UL>
<LI>
<FONT SIZE=+0>команд работы с цепочками, которые могут перемещать данные
из памяти в память;</FONT></LI>

<LI>
<FONT SIZE=+0>команд работы со стеком, которые могут переносить данные
из памяти в стек, также находящийся в памяти;</FONT></LI>

<LI>
<FONT SIZE=+0>команд типа умножения, которые кроме операнда, указанного
в команде, используют еще и второй, неявный операнд.</FONT></LI>
</UL>
<FONT SIZE=+0>Из перечисленных сочетаний операндов наиболее часто употребляются
<I>регистр—память</I> и <I>память—регистр</I>.</FONT>
<BR><FONT SIZE=+0>Ввиду их важности рассмотрим их подробнее. Обсуждение
мы будем сопровождать примерами команд ассемблера, которые будут показывать,
как изменяется формат команды ассемблера при применении того или иного
вида адресации. В связи с этим посмотрите еще раз на <I><A HREF="#Рис_2">рис.
2</A></I>, на котором показан принцип формирования физического адреса на
адресной шине микропроцессора. Видно, что адрес операнда формируется как
сумма двух составляющих — сдвинутого на 4 бит содержимого сегментного регистра
и 16-битного эффективного адреса, который в общем случае вычисляется как
сумма трех компонентов: базы, смещения и индекса.&nbsp;<A NAME="КосвеннаяБазовая"></A></FONT>

<P><FONT SIZE=+0>Перечислим и затем рассмотрим особенности основных видов
адресации операндов в памяти:</FONT>
<UL>
<LI>
<FONT SIZE=+0><A HREF="#ПрямаяАдресация">Прямая адресация</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#КосвеннаяБазовая">Косвенная базовая (регистровая)
адресация</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#КосвеннаяCоCмещением">Косвенная базовая (регистровая)
адресация со смещением</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#КосвеннаяИндекснаяСоСмещением">Косвенная индексная
адресация со смещением</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#КосвеннаяБазоваяИндексная">Косвенная базовая индексная
адресация</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#КосвеннаяБазоваяИндекснаяСоСмещением">Косвенная
базовая индексная адресация со смещением</A></FONT></LI>
</UL>
<A NAME="ПрямаяАдресация"></A>
<H4>
<FONT SIZE=+0>Прямая адресация</FONT></H4>
<FONT SIZE=+0>Это простейший вид адресации операнда в памяти, так как эффективный
адрес содержится в самой команде и для его формирования не используется
никаких дополнительных источников или регистров. Эффективный адрес берется
непосредственно из поля смещения машинной команды (см. <I><A HREF="#Рис_1">рис.
1</A></I>), которое может иметь размер 8, 16, 32 бит. Это значение однозначно
определяет байт, слово или двойное слово, расположенные в сегменте данных.</FONT>

<P><FONT SIZE=+0>Прямая адресация может быть двух типов:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>Относительная прямая адресация</I>. Используется для команд
условных переходов, для указания относительного адреса перехода. Относительность
такого перехода заключается в том, что в поле смещения машинной команды
содержится 8, 16 или 32-битное значение, которое в результате работы команды
будет складываться с содержимым регистра указателя команд ip/eip. В результате
такого сложения получается адрес, по которому и осуществляется переход.</FONT></LI>

<BR><FONT SIZE=+0>Например:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; jс m1&nbsp;&nbsp;&nbsp;&nbsp; ;переход на метку m1, если флаг
cf = 1
&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; al,2
...
m1:</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Несмотря на то, что в команде указана некоторая метка в программе,
ассемблер вычисляет смещение этой метки относительно следующей команды
(в нашем случае это mov al,2) и подставляет его в формируемую машинную
команду jc.</FONT>
<LI>
<FONT SIZE=+0><I>Абсолютная прямая адресация</I>. В этом случае эффективный
адрес является частью машинной команды, но формируется этот адрес только
из значения поля смещения в команде. Для формирования физического адреса
операнда в памяти микропроцессор складывает это поле со сдвинутым на 4
бит значением сегментного регистра. В команде ассемблера можно использовать
несколько форм такой адресации.</FONT></LI>

<BR><FONT SIZE=+0>Например:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,dword ptr [0000]&nbsp;&nbsp;&nbsp;&nbsp; ;записать слово по адресу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ds:0000 в регистр ax</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Но такая адресация применяется редко — обычно используемым
ячейкам в программе присваиваются символические имена. В процессе трансляции
ассемблер вычисляет и подставляет значения смещений этих имен в формируемую
им машинную команду в поле смещение в команде (см. <I><A HREF="#Рис_1">рис.
1</A></I>). В итоге получается так, что машинная команда прямо адресует
свой операнд, имея, фактически, в одном из своих полей значение эффективного
адреса.</FONT>
<BR><FONT SIZE=+0>Например:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
data&nbsp;&nbsp;&nbsp; segment
per1&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5
...
data&nbsp;&nbsp;&nbsp; ends
code&nbsp;&nbsp;&nbsp; segment
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,per1 ;записать слово per1 (его физический адрес ds:0000) в ax</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Мы получим тот же результат, что и при использовании команды
mov ax,dword ptr [0000]</FONT></UL>
<FONT SIZE=+0>Остальные виды адресации относятся к <I>косвенным</I>. Слово
“косвенный” в названии этих видов адресации означает то, что в самой команде
может находиться лишь часть эффективного адреса, а остальные его компоненты
находятся в регистрах, на которые указывают своим содержимым байт modr/m
и, возможно, байт sib.&nbsp;<A NAME="КосвеннаяБазовая"></A></FONT>
<H4>
<FONT SIZE=+0>Косвенная базовая (регистровая) адресация</FONT></H4>
<FONT SIZE=+0>При такой адресации эффективный адрес операнда может находиться
в любом из регистров общего назначения, кроме <I>sp/esp</I> и <I>bp/ebp</I>
(это специфические регистры для работы с сегментом стека). Синтаксически
в команде этот режим адресации выражается заключением имени регистра в
квадратные скобки [ ]. К примеру, команда <B>mov ax,[ecx]</B> помещает
в регистр ax содержимое слова по адресу из сегмента данных со смещением,
хранящимся в регистре ecx. Так как содержимое регистра легко изменить в
ходе работы программы, данный способ адресации позволяет динамически назначить
адрес операнда для некоторой машинной команды. Это свойство очень полезно,
например, для организации циклических вычислений и для работы с различными
структурами данных типа таблиц или массивов.&nbsp;<A NAME="КосвеннаяCоCмещением"></A></FONT>
<H4>
<FONT SIZE=+0>Косвенная базовая (регистровая) адресация со смещением</FONT></H4>
<FONT SIZE=+0>Этот вид адресации является дополнением предыдущего и предназначен
для доступа к данным с известным смещением относительно некоторого базового
адреса. Этот вид адресации удобно использовать для доступа к элементам
структур данных, когда смещение элементов известно заранее, на стадии разработки
программы, а базовый (начальный) адрес структуры должен вычисляться динамически,
на стадии выполнения программы. Модификация содержимого базового регистра
позволяет обратиться к одноименным элементам различных экземпляров однотипных
структур данных.</FONT>
<BR><FONT SIZE=+0>К примеру, команда <B>mov ax,[edx+3h]</B> пересылает
в регистр ax слова из области памяти по адресу: содержимое edx + 3h.</FONT>
<BR><FONT SIZE=+0>Команда <B>mov ax,mas[dx]</B> пересылает в регистр ax
слово по адресу: содержимое dx плюс значение идентификатора mas (не забывайте,
что транслятор присваивает каждому идентификатору значение, равное смещению
этого идентификатора относительно начала сегмента данных).&nbsp;<A NAME="КосвеннаяИндекснаяСоСмещением"></A></FONT>
<H4>
<FONT SIZE=+0>Косвенная индексная адресация со смещением</FONT></H4>
<FONT SIZE=+0>Этот вид адресации очень похож на косвенную базовую адресацию
со смещением. Здесь также для формирования эффективного адреса используется
один из регистров общего назначения. Но индексная адресация обладает одной
интересной особенностью, которая очень удобна для работы с массивами. Она
связана с возможностью так называемого масштабирования содержимого индексного
регистра. Что это такое?</FONT>
<BR><FONT SIZE=+0>Посмотрите на <I><A HREF="#Рис_1">рис. 1</A></I>. Нас
интересует байт <I>sib</I>. При обсуждении структуры этого байта мы отмечали,
что он состоит из трех полей. Одно из этих полей — поле масштаба ss, на
значение которого умножается содержимое индексного регистра.</FONT>
<BR><FONT SIZE=+0>К примеру, в команде <B>mov ax,mas[si*2]</B> значение
эффективного адреса второго операнда вычисляется выражением mas+(si)*2.
В связи с тем, что в ассемблере нет средств для организации индексации
массивов, то программисту своими силами приходится ее организовывать.</FONT>
<BR><FONT SIZE=+0>Наличие возможности масштабирования существенно помогает
в решении этой проблемы, но при условии, что размер элементов массива составляет
1, 2, 4 или 8 байт.&nbsp;<A NAME="КосвеннаяБазоваяИндексная"></A></FONT>
<H4>
<FONT SIZE=+0>Косвенная базовая индексная адресация</FONT></H4>
<FONT SIZE=+0>При этом виде адресации эффективный адрес формируется как
сумма содержимого двух регистров общего назначения: базового и индексного.
В качестве этих регистров могут применяться любые регистры общего назначения,
при этом часто используется масштабирование содержимого индексного регистра.</FONT>
<BR><FONT SIZE=+0>Например:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,[esi][edx]</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>В данном примере эффективный адрес второго операнда формируется
из двух компонентов (esi)+(edx).&nbsp;<A NAME="КосвеннаяБазоваяИндекснаяСоСмещением"></A></FONT>
<H4>
<FONT SIZE=+0>Косвенная базовая индексная адресация со смещением</FONT></H4>
<FONT SIZE=+0>Этот вид адресации является дополнением косвенной индексной
адресации. Эффективный адрес формируется как сумма трех составляющих: cодержимого
базового регистра, cодержимого индексного регистра и значения поля смещения
в команде.</FONT>
<BR><FONT SIZE=+0>К примеру, команда <B>mov eax,[esi+5][edx]</B> пересылает
в регистр eax двойное слово по адресу: (esi) + 5 + (edx).</FONT>
<BR><FONT SIZE=+0>Команда <B>add ax,array[esi][ebx]</B> производит сложение
содержимого регистра ax с содержимым слова по адресу: значение идентификатора
array + (esi) + (ebx).&nbsp;</FONT>&nbsp;
<HR SIZE=5 WIDTH=80%>
</BODY>
<!конец html-документа>
</HTML>
